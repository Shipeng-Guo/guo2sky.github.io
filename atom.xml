<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>果子学生信</title>
  
  <subtitle>一个临床医生的生信之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://guoshipeng.com/"/>
  <updated>2017-12-01T13:38:56.000Z</updated>
  <id>http://guoshipeng.com/</id>
  
  <author>
    <name>Shipeng Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>26-easyTCGA</title>
    <link href="http://guoshipeng.com/2017/12/01/26-easyTCGA/"/>
    <id>http://guoshipeng.com/2017/12/01/26-easyTCGA/</id>
    <published>2017-12-01T13:38:54.000Z</published>
    <updated>2017-12-01T13:38:56.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>R语言的并行化处理-返回多个对象</title>
    <link href="http://guoshipeng.com/2017/11/23/25-R-paralell-subset/"/>
    <id>http://guoshipeng.com/2017/11/23/25-R-paralell-subset/</id>
    <published>2017-11-23T06:09:09.000Z</published>
    <updated>2017-11-23T06:10:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天还是有遗憾，一是没有搞清楚全局赋值号怎么使用，今天过后我觉得昨天五迷三道的<br>二是还是不知道apply和parApply通用的返回多个对象的方法，今天算是解决了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">i &lt;- c(1:100)</div><div class="line">i &lt;- matrix(i,rep(1,length(i)))</div><div class="line">a &lt;&lt;- vector(length = 100, mode = &quot;numeric&quot;)</div><div class="line">b &lt;&lt;- vector(length = 100, mode = &quot;numeric&quot;)</div><div class="line">mytest_fun &lt;- function(i)&#123;</div><div class="line">  a[i] &lt;&lt;- sqrt(i)</div><div class="line">  b[i] &lt;&lt;- log(i)</div><div class="line">&#125;</div><div class="line">result &lt;- apply(i,2,mytest_fun)</div></pre></td></tr></table></figure></p><p>这时候返回的是result是b的结果，而a和b都是有正常结果的，因为我用了&lt;&lt;- 全局赋值符号<br>如果我把外面的&lt;&lt;-去掉呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">i &lt;- c(1:100)</div><div class="line">i &lt;- matrix(i,rep(1,length(i)))</div><div class="line">a &lt;- vector(length = 100, mode = &quot;numeric&quot;)</div><div class="line">b &lt;- vector(length = 100, mode = &quot;numeric&quot;)</div><div class="line">mytest_fun &lt;- function(i)&#123;</div><div class="line">  a[i] &lt;&lt;- sqrt(i)</div><div class="line">  b[i] &lt;&lt;- log(i)</div><div class="line">&#125;</div><div class="line">result &lt;- apply(i,2,mytest_fun)</div></pre></td></tr></table></figure></p><p>结果是一样的，a和b有正常的结果，而result返回的是b<br>如果我把函数里面的&lt;&lt;-去掉呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">i &lt;- c(1:100)</div><div class="line">i &lt;- matrix(i,rep(1,length(i)))</div><div class="line">a &lt;&lt;- vector(length = 100, mode = &quot;numeric&quot;)</div><div class="line">b &lt;&lt;- vector(length = 100, mode = &quot;numeric&quot;)</div><div class="line">mytest_fun &lt;- function(i)&#123;</div><div class="line">  a[i] &lt;- sqrt(i)</div><div class="line">  b[i] &lt;- log(i)</div><div class="line">&#125;</div><div class="line">result &lt;- apply(i,2,mytest_fun)</div></pre></td></tr></table></figure></p><p>里面肯定是不能去的，去掉后就不可能改变外面的a和b<br>所以这个符号只要在函数里面用即可！！<br>但是，洲更说，这种方法太危险！！<br>今天学习GSEA的代码时，返现函数可以返回多个对象的，只要把多个对象组成list，再return即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">i &lt;- c(1:100)</div><div class="line">i &lt;- matrix(i,rep(1,length(i)))</div><div class="line">mytest_fun &lt;- function(i)&#123;</div><div class="line">  a &lt;- sqrt(i)</div><div class="line">  b &lt;- log(i)</div><div class="line">  return(list(a = a,b =b ))##最好对a和b赋值，这样取出时辨识度很高</div><div class="line">&#125;</div><div class="line">result &lt;- apply(i,2,mytest_fun)</div></pre></td></tr></table></figure></p><p>这时候我们发现result是由100个list组成的list，每个list有两个元素<br>我们分别将他们取出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for (i in 1:100) &#123;a[i] &lt;-result[[i]]$a&#125;</div><div class="line">for (i in 1:100) &#123;b[i] &lt;-result[[i]]$b&#125;</div></pre></td></tr></table></figure></p><p>得到了想要的a和b<br>这时候我来看一下parApply能不能这样使用呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mytest_fun &lt;- function(i)&#123;</div><div class="line">  a &lt;- sqrt(i)</div><div class="line">  b &lt;- log(i)</div><div class="line">  return(list(a = a,b =b ))</div><div class="line">&#125;</div><div class="line">i &lt;- c(1:100)</div><div class="line">i &lt;- matrix(i,rep(1,length(i)))</div><div class="line">require(parallel)</div><div class="line">cl.cores &lt;- detectCores()</div><div class="line">cl &lt;- makeCluster(28)</div><div class="line">clusterExport(cl,c(&quot;sqrt&quot;,&quot;i&quot;,&quot;a&quot;,&quot;b&quot;,&quot;log&quot;))</div><div class="line">result &lt;- parApply(cl,i,2,mytest_fun)</div></pre></td></tr></table></figure></p><p>一样的的result<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">for (i in 1:100) &#123;a[i] &lt;-result[[i]]$a&#125;</div><div class="line">for (i in 1:100) &#123;b[i] &lt;-result[[i]]$b&#125;</div></pre></td></tr></table></figure></p><p>取出也是没有问题的！！</p><p>###总结：</p><blockquote><ul><li>函数默认会返回最后一个对象，使用return可以指定返回的对象,而return合用list可以返回多个对象，获取元素时只要使用’$‘符号即可</li><li>而apply以及parApply一样的可以返回多个元素，只是这时候，返回的元素结构产生了变化，不能直接取出，逐个获取！！！</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天还是有遗憾，一是没有搞清楚全局赋值号怎么使用，今天过后我觉得昨天五迷三道的&lt;br&gt;二是还是不知道apply和parApply通用的返回多个对象的方法，今天算是解决了。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="生物信息" scheme="http://guoshipeng.com/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="R" scheme="http://guoshipeng.com/tags/R/"/>
    
      <category term="GSEA" scheme="http://guoshipeng.com/tags/GSEA/"/>
    
      <category term="并行" scheme="http://guoshipeng.com/tags/%E5%B9%B6%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>apply家族的并行化并不完美！！！</title>
    <link href="http://guoshipeng.com/2017/11/22/24-R-paralell/"/>
    <id>http://guoshipeng.com/2017/11/22/24-R-paralell/</id>
    <published>2017-11-22T07:16:36.000Z</published>
    <updated>2017-11-23T06:10:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>在运行完R代码版本的GSEA后，我就在想不能把GSEA并行化运行，<br>最终发现，我并没有得到我想要的结果，百思不得其解，最终准备了一个小测试帮助我理解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">i &lt;- c(1:100)</div><div class="line">i &lt;- matrix(i,rep(1,length(i))) #识别的是矩阵，dim(X) must have a positive length</div><div class="line">a &lt;- vector(length = Ng, mode = &quot;numeric&quot;)</div><div class="line">#写一个函数,计算输入的值的开放，并且存入向量</div><div class="line">mytest_fun &lt;- function(i)&#123;</div><div class="line">  a[i] &lt;- sqrt(i)</div><div class="line">&#125;</div><div class="line">require(parallel)</div><div class="line">cl.cores &lt;- detectCores() #detectCores()检查当前电脑可用核数</div><div class="line">cl &lt;- makeCluster(28) #makeCluster(cl.cores)使用刚才检测的核并行运算</div><div class="line">#这是坑，parApply里面用到的函数以及变量都需要申明</div><div class="line">clusterExport(cl,c(&quot;sqrt&quot;,&quot;i&quot;,&quot;a&quot;))</div><div class="line">parApply(cl,i,2,mytest_fun)</div></pre></td></tr></table></figure><p>最终有结果，但是没有存进a<br>使用&lt;&lt;- 符号设定全局变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">i &lt;- c(1:100)</div><div class="line">i &lt;- matrix(i,rep(1,length(i)))</div><div class="line">a &lt;&lt;- vector(length = Ng, mode = &quot;numeric&quot;)</div><div class="line">mytest_fun &lt;- function(i)&#123;</div><div class="line">  a[i] &lt;&lt;- sqrt(i)</div><div class="line">&#125;</div><div class="line"></div><div class="line">clusterExport(cl,c(&quot;sqrt&quot;,&quot;i&quot;,&quot;a&quot;))</div><div class="line">parApply(cl,i,2,mytest_fun)</div></pre></td></tr></table></figure><p>依然没有存进a中<br>尝试其他两种方法，<br>for循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">a &lt;&lt;- vector(length =100, mode = &quot;numeric&quot;)</div><div class="line">mytest_fun &lt;- function(i)&#123;</div><div class="line">  a[i] &lt;&lt;- sqrt(i)</div><div class="line">&#125;</div><div class="line">for (i in 1:100) mytest_fun(i)</div></pre></td></tr></table></figure></p><p>能够写入a<br>尝试再使用一下apply函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">i &lt;- c(1:100)</div><div class="line">i &lt;- matrix(i,rep(1,length(i)))</div><div class="line">a &lt;&lt;- vector(length =100, mode = &quot;numeric&quot;)</div><div class="line">mytest_fun &lt;- function(i)&#123;</div><div class="line">  a[i] &lt;&lt;- sqrt(i)</div><div class="line">&#125;</div><div class="line">apply(i,2,mytest_fun)</div></pre></td></tr></table></figure></p><p>也能够写入a</p><p>下面尝试函数如何返回多个对象，把不同的结果写入矩阵a和矩阵b<br>parApply肯定是不行的<br>for循环呢？毫无疑问是可以的！！只要设定全局变量即可！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">i &lt;- c(1:100)</div><div class="line">a &lt;&lt;- vector(length = 100, mode = &quot;numeric&quot;)</div><div class="line">b &lt;&lt;- vector(length = 100, mode = &quot;numeric&quot;)</div><div class="line">mytest_fun &lt;- function(i)&#123;</div><div class="line">  a[i] &lt;&lt;- sqrt(i)</div><div class="line">  b[i] &lt;&lt;- log(i)</div><div class="line">&#125;</div><div class="line">for (i in 1:100) mytest_fun(i)</div></pre></td></tr></table></figure></p><p>apply呢？也是可以的！！！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">i &lt;- c(1:100)</div><div class="line">i &lt;- matrix(i,rep(1,length(i)))</div><div class="line">a &lt;&lt;- vector(length = 100, mode = &quot;numeric&quot;)</div><div class="line">b &lt;&lt;- vector(length = 100, mode = &quot;numeric&quot;)</div><div class="line">clusterExport(cl,c(&quot;sqrt&quot;,&quot;i&quot;,&quot;a&quot;,&quot;b&quot;,&quot;log&quot;))</div><div class="line"></div><div class="line">mytest_fun &lt;- function(i)&#123;</div><div class="line">  a[i] &lt;&lt;- sqrt(i)</div><div class="line">  b[i] &lt;&lt;- log(i)</div><div class="line">&#125;</div><div class="line">apply(i,2,mytest_fun)</div></pre></td></tr></table></figure></p><p>被&lt;&lt;-搞糊涂了，最终测试发现，只要在函数里面用这个符号就可以了</p><p>而parApply呢，无论如何返回不了多个对象，看来GSEA的并行化是泡汤了，难怪昨天使用GSEA并行化到了最后总是提示错误<br>原来是他没有返回该返回的对象。</p><p>现在的问题是：parApply不能把结果写入全局变量a中，解决这个问题，就可以把几乎所有的循环并行化啦！！！<br>暂时不能解决！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在运行完R代码版本的GSEA后，我就在想不能把GSEA并行化运行，&lt;br&gt;最终发现，我并没有得到我想要的结果，百思不得其解，最终准备了一个小测试帮助我理解&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
      <category term="生物信息" scheme="http://guoshipeng.com/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="R" scheme="http://guoshipeng.com/tags/R/"/>
    
      <category term="GSEA" scheme="http://guoshipeng.com/tags/GSEA/"/>
    
      <category term="并行" scheme="http://guoshipeng.com/tags/%E5%B9%B6%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>R语言找最小公倍数</title>
    <link href="http://guoshipeng.com/2017/11/20/23-LCM/"/>
    <id>http://guoshipeng.com/2017/11/20/23-LCM/</id>
    <published>2017-11-20T10:37:33.000Z</published>
    <updated>2017-11-23T08:43:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>第5题</p><blockquote><p>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.<br>What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?</p></blockquote><p>找出能被1到20整除的最小数，就是1到20的最小公倍数<br>以直觉来结题，对于每一个数判断他是不是能够被1到20的数整除，如果是就保留下来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">n=1</div><div class="line">while(TRUE)&#123;</div><div class="line">  if (sum(((n)%%seq(1,20) == 0)) &gt;= 20) break</div><div class="line">  n = n +1</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>本质上这个应该能解题，但是算了半天没反应我就只到出问题了<br>花间一下，这个数首先肯定能被20整除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">n=1</div><div class="line">while(TRUE)&#123;</div><div class="line">  if (sum(((20*n)%%seq(1,20) == 0)) &gt;= 20) break</div><div class="line">  n = n +1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>还是算不出来，那应该还要同时被19整除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">n=1</div><div class="line">while(TRUE)&#123;</div><div class="line">  if (sum(((380*n)%%seq(1,20) == 0)) &gt;= 20) break</div><div class="line">  n = n +1</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>最后算出了答案，380*n=232792560</p><p>我看到也可以用分解质数方法来做，但是没有兴趣。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第5题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.&lt;br&gt;Wha
      
    
    </summary>
    
      <category term="Project Euler" scheme="http://guoshipeng.com/categories/Project-Euler/"/>
    
    
      <category term="R" scheme="http://guoshipeng.com/tags/R/"/>
    
      <category term="编程" scheme="http://guoshipeng.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>在R中使用refGenome阅读GTF格式的文件</title>
    <link href="http://guoshipeng.com/2017/11/16/22-GTF-RefG/"/>
    <id>http://guoshipeng.com/2017/11/16/22-GTF-RefG/</id>
    <published>2017-11-16T10:06:11.000Z</published>
    <updated>2017-11-16T10:32:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然我们已经找到<a href="http://guoshipeng.com/2017/11/16/20-GTF-in-R/">在R语言中读取GTF文件的最好方法</a><br>但是不妨碍我们学习新的方法<br>实际上rtracklayer::import就是个另类，一般而言大家读入GTF文件后只有9行<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171116/6hKfCc6Hbd.png" alt="mark"><br>refGenome也是，但是他可以把第九行轻松地取出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">install.packages(&quot;refGenome&quot;)</div><div class="line">library(refGenome)</div></pre></td></tr></table></figure></p><p>create ensemblGenome object for storing Ensembl genomic annotation data<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ens &lt;- ensemblGenome()</div></pre></td></tr></table></figure></p><p>read GTF file into ensemblGenome object<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">read.gtf(ens, &quot;Homo_sapiens.GRCh38.90.chr.gtf&quot;)</div></pre></td></tr></table></figure></p><blockquote><p>read.gtf(ens, “Homo_sapiens.GRCh38.90.chr.gtf”)<br>[read.gtf.refGenome] Reading file ‘Homo_sapiens.GRCh38.90.chr.gtf’.<br>[GTF]  2612134 lines processed.<br>[read.gtf.refGenome] Extracting genes table.<br>[read.gtf.refGenome] Found 58,243 gene records.<br>[read.gtf.refGenome] Finished.</p></blockquote><p>看一下他属性</p><blockquote><p>class(ens)<br>[1] “ensemblGenome”<br>attr(,”package”)<br>[1] “refGenome”</p></blockquote><p>本次的重点来了create table of genes<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">my_gene &lt;- getGenePositions(ens)</div></pre></td></tr></table></figure></p><blockquote><p>class(my_gene)<br>[1] “data.frame”<br>dim(my_gene)<br>[1] 58243    26</p></blockquote><p>这26个是变量分别是：</p><blockquote><p>testmygene &lt;- my_gene[1:5,]<br>View(testmygene)<br>names(testmygene)<br>[1] “id”                      “seqid”<br>[3] “source”                  “start”<br>[5] “end”                      “score”<br>[7] “strand”                  “frame”<br>[9] “ccds_id”                  “protein_version”<br>[11] “protein_id”              “exon_version”<br>[13] “transcript_support_level” “tag”<br>[15] “exon_number”              “gene_id”<br>[17] “transcript_name”          “gene_version”<br>[19] “gene_name”                “gene_source”<br>[21] “gene_biotype”            “transcript_id”<br>[23] “transcript_source”        “exon_id”<br>[25] “transcript_version”      “transcript_biotype”</p></blockquote><p>获取也是非常容易。<br>其实这个功能完全是可以自己写个函数来搞定的，之前已经写过了。<br>根据这个帖子结合dplyr，他还可以做很多事情<br><a href="https://davetang.org/muse/2017/08/04/read-gtf-file-r/" target="_blank" rel="external">Read GTF file into R</a><br>同时这个文章的作者已经坚持写作7年，是个生物信息学的大神，收入书签！<br>比如可以每个染色体上有哪些gene类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">my_gene %&gt;% group_by(seqid, gene_biotype) %&gt;% summarise(count = n()) -&gt; my_tally</div><div class="line">ggplot(my_tally, aes(x =seqid, y = log2(count))) +</div><div class="line">  geom_bar(aes(fill = gene_biotype), stat = &apos;identity&apos;, position = &apos;dodge&apos;)</div></pre></td></tr></table></figure></p><p><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171116/9jdmiI5dLf.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然我们已经找到&lt;a href=&quot;http://guoshipeng.com/2017/11/16/20-GTF-in-R/&quot;&gt;在R语言中读取GTF文件的最好方法&lt;/a&gt;&lt;br&gt;但是不妨碍我们学习新的方法&lt;br&gt;实际上rtracklayer::import就是个另类，一般而
      
    
    </summary>
    
      <category term="生物信息" scheme="http://guoshipeng.com/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="R" scheme="http://guoshipeng.com/tags/R/"/>
    
      <category term="TCGA" scheme="http://guoshipeng.com/tags/TCGA/"/>
    
  </entry>
  
  <entry>
    <title>在R语言中读取TCGA的json文件并且获取样本ID</title>
    <link href="http://guoshipeng.com/2017/11/16/21-R-TCGA-json/"/>
    <id>http://guoshipeng.com/2017/11/16/21-R-TCGA-json/</id>
    <published>2017-11-16T09:00:11.000Z</published>
    <updated>2017-11-16T09:01:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>TCGA的原始数据下载后，只有一串字母混合的代号，没有样本号，所有的信息都存在metadata中，但是他的形式是json<br>现在我们来读取json,需要安装jsonlite包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">metadata &lt;- jsonlite::fromJSON(&quot;metadata.cart.2017-11-15T09_56_59.722935.json&quot;)</div><div class="line">library(tidyverse)</div><div class="line">metadata_id &lt;- metadata %&gt;%</div><div class="line">  select(c(file_name,associated_entities))</div></pre></td></tr></table></figure></p><p>最终读到1208个观测，15个变量，我需要的是file_name和样本名称，样本名称藏在了associated_entities 列表中<br>里面包括了entity_id,case_id,entity_submitter_id,entity_type这四个项目，查看第一个了解一下</p><blockquote><p>metadata$associated_entities[1]<br>[[1]]<br>                            entity_id                              case_id<br>1 52033f64-1e6f-4657-a4fb-7cfeffc61951 39de7761-e762-4811-b95c-8216b79ae06b<br>          entity_submitter_id entity_type<br>1 TCGA-AN-A0XW-01A-11R-A109-07    aliquot</p></blockquote><p>现在的想法是我把ilename和associated_entities中的entity_submitter_id提取出来，放入列表中，形成1208个小列表<br>每个小列表中包含两个元素，即lename和entity_submitter_id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">name_id &lt;- list()</div><div class="line">for (i in 1:1208)&#123;</div><div class="line">  name_id[[i]] &lt;- substr(metadata_id$file_name[i],1,nchar(metadata_id$file_name[i])-3)</div><div class="line">  name_id[[i]][2] &lt;- metadata_id$associated_entities[i][[1]]$entity_submitter_id</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>##不是很方便尝试直接把list转化成datafram，感受一下do.call的另类用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">naid_df &lt;- as.data.frame(do.call(rbind, name_id))</div></pre></td></tr></table></figure></p><p>得到的naid_df是一个2列1208行的数据框，实际上一开始避开list也可以完成，只是我选择了list，正好使用一下do.call</p><p>现在把1208个小文件读入一个矩阵文件，并且给每一个文件加上filename和entity_submitter_id<br>之前有个帖子介绍过<br><a href="http://guoshipeng.com/2017/11/10/14-R-for-binding-colums/#more">在R语言中将多个同样的行列式文件合并起来</a><br>但是当时不知道，TCGA的单个文件是没有列名的，导致无法合并，本次要复杂一点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#读入所有解压的文件 1208个，参考[R语言中选取多个文件夹中的文件合并到新的文件夹](http://guoshipeng.com/2017/11/13/15-multiple-files-into-one-by-R/)</div><div class="line">nameList &lt;- list.files(&quot;data_unzip/&quot;)</div><div class="line">location &lt;- which(naid_df==nameList[1],arr.ind = TRUE) ##which函数有一个已知value返回坐标的功能</div><div class="line">TCGA_id &lt;- as.character(naid_df[location[1],2]) ##通过坐标，获取TCGA_id</div><div class="line">expr_df&lt;- read.table(paste0(&quot;data_unzip/&quot;,nameList[1]),stringsAsFactors = F, header = F) #读入第一个文件，保存为data.frame</div><div class="line">names(expr_df) &lt;- c(&quot;gene_id&quot;,TCGA_id) #给刚才数据库命名</div></pre></td></tr></table></figure></p><p>这边开始批量作业<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (i in 2:length(nameList))&#123;</div><div class="line">  location &lt;- which(naid_df==nameList[i],arr.ind = TRUE)</div><div class="line">  TCGA_id &lt;- as.character(naid_df[location[1],2])</div><div class="line">  dfnew &lt;- read.table(paste0(&quot;data_unzip/&quot;,nameList[i]),stringsAsFactors = F,header = F)</div><div class="line">  names(dfnew) &lt;- c(&quot;gene_id&quot;,TCGA_id)</div><div class="line">  expr_df &lt;- inner_join(expr_df,dfnew,by=&quot;gene_id&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>晚上走的时候没运行完，早上来的时候已经完毕，限速环节应该是read.table，早上再来尝试运行一次总是说内存不够<br>我想到之前阅读GTF时，fread的速度很快，就试了一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">library(data.table)</div><div class="line">nameList &lt;- list.files(&quot;data_unzip/&quot;)</div><div class="line">location &lt;- which(naid_df==nameList[1],arr.ind = TRUE)</div><div class="line">TCGA_id &lt;- as.character(naid_df[location[1],2])</div><div class="line">expr_df&lt;- fread(paste0(&quot;data_unzip/&quot;,nameList[1]))</div><div class="line">names(expr_df) &lt;- c(&quot;gene_id&quot;,TCGA_id)</div><div class="line"></div><div class="line">for (i in 2:length(nameList))&#123;</div><div class="line">  location &lt;- which(naid_df==nameList[i],arr.ind = TRUE)</div><div class="line">  TCGA_id &lt;- as.character(naid_df[location[1],2])</div><div class="line">  dfnew &lt;- fread(paste0(&quot;data_unzip/&quot;,nameList[i]))</div><div class="line">  names(dfnew) &lt;- c(&quot;gene_id&quot;,TCGA_id)</div><div class="line">  expr_df &lt;- inner_join(expr_df,dfnew,by=&quot;gene_id&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>大概花了15分钟左右<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">save(expr_df,file = &quot;brca_expr_df.Rda&quot;)</div></pre></td></tr></table></figure></p><p>如果下次使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">load(file = &quot;brca_expr_df.Rda&quot;)</div></pre></td></tr></table></figure></p><p>更新：无意间看一个帖子说list的获取可以使用$符号，但是在储存的时候要有特定的格式，相当于把第一个变量当做名称，直接￥调用<br>如果成功的话，之前汇总文件的过程就会简单一点,应该是这种格式的循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">name_id &lt;- list()</div><div class="line">for (i in 1:1208)&#123;</div><div class="line">  list_name &lt;- substr(metadata_id$file_name[i],1,nchar(metadata_id$file_name[i])-3)</div><div class="line">  name_id$list_name &lt;- metadata_id$associated_entities[i][[1]]$entity_submitter_id</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>使用第一个文件试一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">list_name &lt;- substr(metadata_id$file_name[1],1,nchar(metadata_id$file_name[1])-3)</div><div class="line">name_id$list_name &lt;- metadata_id$associated_entities[1][[1]]$entity_submitter_id</div></pre></td></tr></table></figure></p><p>测试 一下</p><blockquote><p>name_id<br>$list_name<br>[1] “TCGA-AN-A0XW-01A-11R-A109-07”</p></blockquote><p>不对,直接把list_name的表达式放进去又不识别，换成下面的表达式还是不行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name_id &lt;- list(substr(metadata_id$file_name[1],1,nchar(metadata_id$file_name[1])-3) = metadata_id$associated_entities[1][[1]]$entity_submitter_id)</div></pre></td></tr></table></figure></p><p>看到$符号，我想到我可以把这些数据弄进数据框，只有两行，行名是filename,把TCGAid弄成一行</p><p>试一下第一个数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">name_id &lt;- data.frame()</div><div class="line">list_name &lt;- substr(metadata_id$file_name[1],1,nchar(metadata_id$file_name[1])-3)</div><div class="line">name_id$list_name &lt;- metadata_id$associated_entities[1][[1]]$entity_submitter_id</div></pre></td></tr></table></figure></p><p>不能运行,换一种表达方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">name_id &lt;- data.frame()</div><div class="line">name_id[1,1] &lt;- metadata_id$associated_entities[1][[1]]$entity_submitter_id</div><div class="line">names(name_id)[1] &lt;- substr(metadata_id$file_name[1],1,nchar(metadata_id$file_name[1])-3)</div></pre></td></tr></table></figure></p><p>成功，批量运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">name_id &lt;- data.frame()</div><div class="line">for (i in 1:1208)&#123;</div><div class="line">  name_id[1,i] &lt;- metadata_id$associated_entities[i][[1]]$entity_submitter_id</div><div class="line">  names(name_id)[i] &lt;- substr(metadata_id$file_name[i],1,nchar(metadata_id$file_name[i])-3)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行成功，速度也很快，下面提取每个数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nameList &lt;- list.files(&quot;data_unzip/&quot;)</div><div class="line">TCGA_id &lt;- name_id$nameList[1]#这一步失败，最后发现是字符串中有-号，暂时没能解决</div></pre></td></tr></table></figure></p><p>总结：<br>fread速度很快<br>R语言的data.frame如果列名包含“-”，无法使用$获取元素，在list中也是一样的情况<br>等以后看能不能解决这个问题吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;TCGA的原始数据下载后，只有一串字母混合的代号，没有样本号，所有的信息都存在metadata中，但是他的形式是json&lt;br&gt;现在我们来读取json,需要安装jsonlite包。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;
      
    
    </summary>
    
      <category term="生物信息" scheme="http://guoshipeng.com/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="R" scheme="http://guoshipeng.com/tags/R/"/>
    
      <category term="TCGA" scheme="http://guoshipeng.com/tags/TCGA/"/>
    
      <category term="编程" scheme="http://guoshipeng.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>在R语言中读取GTF文件的最好方法</title>
    <link href="http://guoshipeng.com/2017/11/16/20-GTF-in-R/"/>
    <id>http://guoshipeng.com/2017/11/16/20-GTF-in-R/</id>
    <published>2017-11-16T07:46:56.000Z</published>
    <updated>2017-11-16T08:28:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>下载的TCGA数据是没有注释的，需要从ensemble上面下载GTF文件，现在需要把GTF文件读入R</p><h2 id="第一种方法rtracklayer-import"><a href="#第一种方法rtracklayer-import" class="headerlink" title="第一种方法rtracklayer::import"></a>第一种方法rtracklayer::import</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">source(&quot;https://bioconductor.org/biocLite.R&quot;)</div><div class="line">biocLite(&quot;rtracklayer&quot;)</div><div class="line">biocLite(&quot;SummarizedExperiment&quot;)</div><div class="line">gtf1 &lt;- rtracklayer::import(&apos;Homo_sapiens.GRCh38.90.chr.gtf&apos;)</div><div class="line">gtf_df &lt;- as.data.frame(gtf1)</div></pre></td></tr></table></figure><p>最终读入27个变量，2612129个观测，测试一下显示的不错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">test &lt;- gtf_df[1:5,]</div><div class="line">View(test)</div></pre></td></tr></table></figure></p><p>取出我需要的gene_id,gene_biotype,gene_name，成为新的数据框<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">geneid_df &lt;- dplyr::select(gtf_df,c(gene_name,gene_id,gene_biotype))</div></pre></td></tr></table></figure></p><h2 id="第二种方法read-table"><a href="#第二种方法read-table" class="headerlink" title="第二种方法read.table"></a>第二种方法read.table</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gtf2 &lt;- read.table(&apos;Homo_sapiens.GRCh38.90.chr.gtf&apos;, header = FALSE, sep = &apos;\t&apos;)</div></pre></td></tr></table></figure><p>最后发现，速度奇慢无比,取消参考了Y叔的帖子增加参数，读入成功，需要1分钟,读入9个变量<br><a href="https://mp.weixin.qq.com/s?__biz=MzI5NjUyNzkxMg==&amp;mid=2247483986&amp;idx=1&amp;sn=43214f77337bc660a733bbc80ab1124b&amp;chksm=ec43b315db343a03cd51ee6cb96e1646975d08e9ea7a980bed236472b77bc6166e601a977dab&amp;mpshare=1&amp;scene=1&amp;srcid=1116dPlFaunZobi46nhFTAM5#rd" target="_blank" rel="external">根据GTF画基因的多个转录本结构</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gtf2 &lt;- read.table(&apos;Homo_sapiens.GRCh38.90.chr.gtf&apos;, stringsAsFactors = F, header = FALSE, sep = &apos;\t&apos;,comment = &quot;#&quot;)</div><div class="line">test2  &lt;- gtf2[1:5,]</div></pre></td></tr></table></figure></p><h2 id="第三种方法readr包里面的read-table2"><a href="#第三种方法readr包里面的read-table2" class="headerlink" title="第三种方法readr包里面的read_table2"></a>第三种方法readr包里面的read_table2</h2><p>速度很快，有进度条，读入了18个变量，但是最gene_biotype显示不对<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">gtf3 &lt;- readr::read_table2(&quot;Homo_sapiens.GRCh38.90.chr.gtf&quot;,comment = &quot;#&quot;)</div><div class="line">gtf_df3 &lt;- as.data.frame(gtf3) #转成data.frame</div><div class="line">test3 &lt;- gtf_df3[1:5,]</div><div class="line">View(test3)</div></pre></td></tr></table></figure></p><h2 id="第四种方法read-table，fread"><a href="#第四种方法read-table，fread" class="headerlink" title="第四种方法read.table，fread"></a>第四种方法read.table，fread</h2><p>读入数据跟read.table一样，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">library(data.table)</div><div class="line">genes &lt;- fread(&quot;Homo_sapiens.GRCh38.90.chr.gtf&quot;)</div><div class="line">test4&lt;- genes[1:5,]</div><div class="line">View(test4)</div></pre></td></tr></table></figure></p><p><strong>上一步用时12秒，速度极快,只是读入后没有名字，需要自己添加</strong><br>读入9个变量,跟read.table一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">setnames(genes, names(genes), c(&quot;chr&quot;,&quot;source&quot;,&quot;type&quot;,&quot;start&quot;,&quot;end&quot;,&quot;score&quot;,&quot;strand&quot;,&quot;phase&quot;,&quot;attributes&quot;) )</div></pre></td></tr></table></figure></p><p>可选步骤，type那一项有转录本和gene，选取gene，其他有很多转录本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">genes &lt;- genes[type == &quot;gene&quot;]</div></pre></td></tr></table></figure></p><p>我要的信息粗存在attributes中，构建函数提取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">extract_attributes &lt;- function(gtf_attributes, att_of_interest)&#123;</div><div class="line">  att &lt;- strsplit(gtf_attributes,&quot;; &quot;)</div><div class="line">  att &lt;- gsub(&quot;\&quot;&quot;,&quot;&quot;,unlist(att))</div><div class="line">  if(!is.null(unlist(strsplit(att[grep(att_of_interest, att)], &quot; &quot;))))&#123;</div><div class="line">    return( unlist(strsplit(att[grep(att_of_interest, att)], &quot; &quot;))[2])</div><div class="line">  &#125;else&#123;</div><div class="line">    return(NA)&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>举例子解释,加入我们需要gene_id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gtf_attributes &lt;- genes[1,9]</div><div class="line">att &lt;- strsplit(gtf_attributes,&quot;; &quot;)</div></pre></td></tr></table></figure></p><p>这一步提示non-character argument，后面我查询才知道, 对于第九列的第一行的的获取两种方式返回的格式不一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">genes[1,9] #data.frame</div><div class="line">genes$attributes[1] #character</div></pre></td></tr></table></figure></p><p>而strsplit的对象是character,重来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gtf_attributes &lt;- genes$attributes[1]</div><div class="line">att &lt;- strsplit(gtf_attributes,&quot;; &quot;)</div><div class="line">att &lt;- gsub(&quot;\&quot;&quot;,&quot;&quot;,unlist(att))</div></pre></td></tr></table></figure></p><p>grep获取位置，获取到内容后分隔,得到的第二个元素是我们需要的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">unlist(strsplit(att[grep(&quot;gene_id&quot;, att)], &quot; &quot;))[2]</div></pre></td></tr></table></figure></p><p>利用函数获得基因列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">genes$gene_id &lt;- unlist(lapply(genes$attributes, extract_attributes, &quot;gene_id&quot;))</div></pre></td></tr></table></figure></p><p>如果我们选择使用第一种方法rtracklayer::import，这些事情都是不需要做的！！！</p><p>#总结：rtracklayer::import最简单，fread最快，read.table可选，read_table没戏！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下载的TCGA数据是没有注释的，需要从ensemble上面下载GTF文件，现在需要把GTF文件读入R&lt;/p&gt;
&lt;h2 id=&quot;第一种方法rtracklayer-import&quot;&gt;&lt;a href=&quot;#第一种方法rtracklayer-import&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="生物信息" scheme="http://guoshipeng.com/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="R" scheme="http://guoshipeng.com/tags/R/"/>
    
      <category term="TCGA" scheme="http://guoshipeng.com/tags/TCGA/"/>
    
      <category term="编程" scheme="http://guoshipeng.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>用R语言来找回文数</title>
    <link href="http://guoshipeng.com/2017/11/15/19-find-palin/"/>
    <id>http://guoshipeng.com/2017/11/15/19-find-palin/</id>
    <published>2017-11-15T10:31:38.000Z</published>
    <updated>2017-11-15T10:33:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>第4题</p><blockquote><p>A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.<br>Find the largest palindrome made from the product of two 3-digit numbers.</p></blockquote><p>意思是找出两个三位数乘积的最大回文数。<br>最朴素的思路：写一个能判断回文数的函数，把三位数的乘积全部求出，一个个判断是否是回文数，再求最大数。<br>1.首先我们创建一个函数来判断回文数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if.palin &lt;- function(x)&#123;</div><div class="line">  a &lt;- as.character(x)</div><div class="line">  b &lt;- unlist(strsplit(a,&quot;&quot;))</div><div class="line">  if (all(b==b[length(b):1])) return (TRUE)</div><div class="line">  else return(FALSE)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>2.穷尽所有的三位数乘三位数的乘积<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">g &lt;- 0</div><div class="line">palin &lt;- c()</div><div class="line">for (i in 100:999)&#123;</div><div class="line">  for (j in 100:999)&#123;</div><div class="line">    if (if.palin(i*j)==TRUE)&#123;</div><div class="line">      g &lt;- g +1</div><div class="line">      palin[g] &lt;- i*j</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>3.找出最大的回文数<br>max(palin)</p><blockquote><p>906609</p></blockquote><p>4.如果想知道每个回文数是由哪两个数组成的怎么办？<br>改写一下代码，每次把结果存入列表中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">g &lt;- 0</div><div class="line">palin &lt;- list()</div><div class="line">for (i in 100:999)&#123;</div><div class="line">  for (j in 100:999)&#123;</div><div class="line">    if (if.palin(i*j)==TRUE)&#123;</div><div class="line">      g &lt;- g +1</div><div class="line">      palin[g] &lt;- list(c(i*j,i,j))</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>获取列表中每个列表的第一个数，注意”[[“在这个时候代表的是函数，表示获取<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">all &lt;- sapply(palin,&quot;[[&quot;,1)</div><div class="line">max(all)</div></pre></td></tr></table></figure></p><p>得到906609，根据这个数值获取位置</p><blockquote><p>which(all ==906609)<br>[1] 2367 2468</p></blockquote><p>有两个位置，这个情况是由之前的循环导致的，应该是一样的结果，只是顺序对调。</p><blockquote><p>palin[2367]<br>[[1]]<br>[1] 906609    913    993</p></blockquote><p>最终最大的回文数是906609，由913乘以993得到<br>note：<br>1.本次练习开始写函数，参考资料为Advanced R 第二版，但是这函数只能起到判断的作用。<br>2.rev()函数可以实现向量倒序，代替b[length(b):1])) = rev(b)<br>3.切开字符串使用strsplit,如果在拼回去需要用paste</p><blockquote><p>paste(c(“B”,”S”),collapse = “”)<br>[1] “BS”</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第4题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit number
      
    
    </summary>
    
      <category term="Project Euler" scheme="http://guoshipeng.com/categories/Project-Euler/"/>
    
    
      <category term="R" scheme="http://guoshipeng.com/tags/R/"/>
    
      <category term="编程" scheme="http://guoshipeng.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>万万使不得！-R语言中的循环套循环</title>
    <link href="http://guoshipeng.com/2017/11/15/18-find-prime/"/>
    <id>http://guoshipeng.com/2017/11/15/18-find-prime/</id>
    <published>2017-11-15T02:32:57.000Z</published>
    <updated>2017-11-15T02:35:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是第3题</p><blockquote><p>The prime factors of 13195 are 5, 7, 13 and 29.<br>What is the largest prime factor of the number 600851475143 ?</p></blockquote><p>就是找出600851475143中最大的质数。<br>我的思路是，找出小于600851475143的质数，得到质数表，然后用600851475143除以这些质数再判断<br>首先找出小于600851475143的质数<br>思路是，如果一个数不能被其他除了自己和1的数整除，那么他就是质数，很明显我是按照定义来的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">k &lt;- 2</div><div class="line">x &lt;-c(2,3)</div><div class="line">for (j in 5:600851475143)&#123;</div><div class="line">  a &lt;-c()</div><div class="line">  for (i in 2:(j-1))&#123;</div><div class="line">    a[i-1] = sum( j%%i == 0)</div><div class="line">  &#125;</div><div class="line">  if (sum(a)==0)&#123;</div><div class="line">    k = k + 1</div><div class="line">    x[k] = j</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行后提示：</p><blockquote><p>Error: cannot allocate vector of size 4476.7 Gb</p></blockquote><p>我想了一下，不需要数到600851475143，到他的平方根即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">k &lt;- 2</div><div class="line">x &lt;-c(2,3)</div><div class="line">for (j in 5:sqrt(600851475143))&#123;</div><div class="line">  a &lt;-c()</div><div class="line">  for (i in 2:(j-1))&#123;</div><div class="line">    a[i-1] = sum( j%%i == 0)</div><div class="line">  &#125;</div><div class="line">  if (sum(a)==0)&#123;</div><div class="line">    k = k + 1</div><div class="line">    x[k] = j</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这一次应该可以，但是运行时间太久，我等了半天都不行，我先测试一下代码是否正确<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">k &lt;- 2</div><div class="line">x &lt;-c(2,3)</div><div class="line">for (j in 5:10000)&#123;</div><div class="line">  a &lt;-c()</div><div class="line">  for (i in 2:(j-1))&#123;</div><div class="line">    a[i-1] = sum( j%%i == 0)</div><div class="line">  &#125;</div><div class="line">  if (sum(a)==0)&#123;</div><div class="line">    k = k + 1</div><div class="line">    x[k] = j</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行大概需要20s，k是1229,说明找到了1229个质数，最大的是max(x),9973<br>那么用600851475143除以x[k],先看看这一群中能除尽的最大数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">y &lt;- 600851475143</div><div class="line">x[which(y %% x==0)]</div></pre></td></tr></table></figure></p><p>输出结果是</p><blockquote><p>x[which(y %% x==0)]<br>[1] 71 839 1471 6857</p></blockquote><p>最大是6857，恰巧这四个数的乘积就是600851475143，说明蒙对了。<br>我在想有没有什么通用的方法呢？在网上检索了一下质数的查找方法<br><a href="http://blog.csdn.net/streetballerym/article/details/48983309" target="_blank" rel="external">找质数算法之埃拉托色尼筛选法-Sieve of Eratosthenes算法</a><br>在R语言中使用这个方法获取质数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">x &lt;- 600851475143</div><div class="line">num &lt;- 2:sqrt(x)</div><div class="line">i &lt;- 0</div><div class="line">wt &lt;- c(2) #用于储存质数</div><div class="line">repeat&#123;</div><div class="line">  i &lt;- i +1</div><div class="line">  num &lt;- num[which(num %% num[1] !=0)] #每次把第一个数以及他的倍数去除</div><div class="line">  wt[i+1] &lt;- num[1] #把第一个数传入向量中</div><div class="line">  if (length(num) == 0) break #repeat需要设定终止条件</div><div class="line">&#125;</div><div class="line">wt &lt;- wt[-length(wt)] #去掉最后一个NA</div></pre></td></tr></table></figure></p><p>最终发现这个方法是可行的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">y &lt;- 600851475143</div><div class="line">wt[which(y %% wt==0)]</div></pre></td></tr></table></figure></p><blockquote><p>wt[which(y %% wt==0)]<br>[1] 71 839 1471 6857</p></blockquote><p>这时候确定无疑就是6857，并且很高兴解决了这么多问题，然后就去参考一下别人博客的答案</p><p>这个先写了一个能判断质数的函数，其中all用的很传神，我在之前不知道有这个函数，就用了迂回的方法代替<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">findprime &lt;- function(x) &#123;</div><div class="line">  if (x %in% c(2,3,5,7)) return(TRUE)</div><div class="line">  if (x%%2 == 0 | x==1) return(FALSE)</div><div class="line">  xsqrt &lt;- round(sqrt(x))</div><div class="line">  xseq &lt;- seq(from=3,to=xsqrt,by=2)</div><div class="line">  if (all(x %% xseq !=0)) return(TRUE)</div><div class="line">  else return(FALSE)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>测试一下效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = 1:700000</div><div class="line">x[sapply(x,findprime)]</div></pre></td></tr></table></figure></p><p>发现速度特别快,下面找出最大的质数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">n &lt;- 600851475143</div><div class="line">for (i in seq(from=3, to=round(sqrt(n)), by=2)) &#123;</div><div class="line">  if (findprime(i) &amp; n %% i == 0) &#123;</div><div class="line">    n &lt;- n / i</div><div class="line">    prime.factor &lt;- i       </div><div class="line">    if (i &gt;= n) break</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">print(prime.factor)</div></pre></td></tr></table></figure></p><p>得到的答案是6857，而且速度很快，几乎是秒出，太惊讶了！！！<br>修改一下代码，得到所有的质数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">n &lt;- 600851475143</div><div class="line">j &lt;- 0</div><div class="line">factor &lt;- c()</div><div class="line">for (i in seq(from=3, to=round(sqrt(n)), by=2)) &#123;</div><div class="line">  if (findprime(i) &amp; n %% i == 0) &#123;</div><div class="line">    n &lt;- n / i</div><div class="line">    j &lt;- j + 1</div><div class="line">    factor[j] &lt;- i       </div><div class="line">    if (i &gt;= n) break</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">print(factor)</div></pre></td></tr></table></figure></p><blockquote><p>print(factor)<br>[1] 71 839 1471 6857</p></blockquote><p>总结：<br>1.使用字母时为什么常用i和j呢？因为他们大小写不容易混淆，我今天使用的是k，大小写分不清，会出现object “k” not found 的提示<br>2.要学会写函数<br>3.尽量不要循环里面套循环，速度会很慢<br>4.all()和any()的用法<br>5.学习Adcanced R里面的函数章节<br>函数<a href="https://adv-r.hadley.nz/functions" target="_blank" rel="external">Functions</a><br>泛函数<a href="https://adv-r.hadley.nz/functionals" target="_blank" rel="external">Functionals</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是第3题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The prime factors of 13195 are 5, 7, 13 and 29.&lt;br&gt;What is the largest prime factor of the number 600851475143 
      
    
    </summary>
    
      <category term="Project Euler" scheme="http://guoshipeng.com/categories/Project-Euler/"/>
    
    
      <category term="R" scheme="http://guoshipeng.com/tags/R/"/>
    
      <category term="编程" scheme="http://guoshipeng.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>R语言中的循环</title>
    <link href="http://guoshipeng.com/2017/11/14/17-loops-in-r/"/>
    <id>http://guoshipeng.com/2017/11/14/17-loops-in-r/</id>
    <published>2017-11-14T01:58:33.000Z</published>
    <updated>2017-11-14T05:07:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>Project Euler01<br>Problem 2, Even Fibonacci numbers</p><blockquote><p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:<br>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …<br>By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.</p></blockquote><p>400万以内的偶数斐波那契数列求和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">x[1] &lt;- 1</div><div class="line">x[2] &lt;- 2</div><div class="line">for (i in 3:1000)&#123;</div><div class="line">  x[i]=x[i-1] +f[i-2]</div><div class="line">  if (x[i] &gt; 4000000)&#123;</div><div class="line">    break</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">x &lt;- x[-i]</div><div class="line">sum(x[x %% 2 == 0])</div></pre></td></tr></table></figure><p>结果4613732<br>但是我并不知道x[i] &gt; 4000000时i是多少，看了别人的答案可以使用while解决这个问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">i &lt;- 2</div><div class="line">x &lt;- 1:2</div><div class="line">while (x[i] &lt; 4e6) &#123;</div><div class="line">  x[i+1] &lt;- x[i-1] + x[i]</div><div class="line">  i &lt;- i + 1</div><div class="line">&#125;</div><div class="line">x &lt;- x[-i]</div><div class="line">sum(x[x %% 2 == 0])</div></pre></td></tr></table></figure></p><p>看了一下<a href="https://www.r-bloggers.com/project-euler-problem-2-2/" target="_blank" rel="external">r-bloggers上别人的答案</a><br>发现还可以用repeat这个命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">fibonacci &lt;- numeric()</div><div class="line">fibonacci[1] &lt;- 1</div><div class="line">fibonacci[2] &lt;- 2</div><div class="line">i &lt;- 3</div><div class="line">repeat &#123;</div><div class="line">  fibonacci[i] &lt;- fibonacci[i-1] + fibonacci[i-2]</div><div class="line">  if (fibonacci[i] &gt; 4e6) break</div><div class="line">  i &lt;- i + 1</div><div class="line">&#125;</div><div class="line"># calculate the sum</div><div class="line">fibonacci &lt;- fibonacci[-length(fibonacci)]  # remove the last term</div><div class="line">flag &lt;- fibonacci %% 2 == 0  # find the indexes of even numbers</div><div class="line">result &lt;- sum(fibonacci[flag])</div><div class="line">cat(&quot;The result is:&quot;, result, &quot;\n&quot;)</div></pre></td></tr></table></figure></p><p>现在有两个问题<br>1.repeat和while有什么区别？<br>2.R语言中的循环有多少种？<br>for,while,repeat,向量化操作,apply,自己写的函数也算。<br>这里有一份来自Datacamp的Tutorials十分值得阅读，价值250美元，很长很全面，但是很好懂<br><a href="https://www.datacamp.com/community/tutorials/tutorial-on-loops-in-r" target="_blank" rel="external">A Tutorial on Loops in R - Usage and Alternatives</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Project Euler01&lt;br&gt;Problem 2, Even Fibonacci numbers&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Each new term in the Fibonacci sequence is generated by adding t
      
    
    </summary>
    
      <category term="Project Euler" scheme="http://guoshipeng.com/categories/Project-Euler/"/>
    
    
      <category term="R" scheme="http://guoshipeng.com/tags/R/"/>
    
      <category term="编程" scheme="http://guoshipeng.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>R语言究竟能不能优雅？</title>
    <link href="http://guoshipeng.com/2017/11/13/16-project-eluer-01-3-and-5/"/>
    <id>http://guoshipeng.com/2017/11/13/16-project-eluer-01-3-and-5/</id>
    <published>2017-11-13T11:12:50.000Z</published>
    <updated>2017-11-14T05:07:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Project Euler01<br>今天我无意间进入肖凯的博客，看到这样一篇文章<br><a href="http://xccds1977.blogspot.hk/2012/02/r_24.html" target="_blank" rel="external">R语言编程入门之二：对象和类</a><br>讲得挺好，但是我还是不能理解面向编程这一套逻辑，最近会解决这个问题</p><p>然后在逛博客的时候发现他写的<a href="http://xccds1977.blogspot.hk/2012/08/r1.html" target="_blank" rel="external">笨办法学R编程</a><br>里面举的例子就是<a href="https://projecteuler.net/" target="_blank" rel="external">Project Euler</a> 上的第一题,Project Euler是一系列由易到难的计算机编程挑战，<br>它提供了一个平台来激发我们解决问题的灵感和思路。</p><blockquote><p>找到1000以下，所有能被3或5整除的数，将它们相加</p></blockquote><p>原文如下：</p><blockquote><p>If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.<br>Find the sum of all the multiples of 3 or 5 below 1000.</p></blockquote><p>我一看挺简单，就尝试做了一下，中途好几次想看答案，忍住没看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">n =0</div><div class="line">a =c()</div><div class="line">for (x in 1:999) &#123;</div><div class="line">  if (x %% 3==0 | x %% 5 == 0)&#123;</div><div class="line">  n = n +1</div><div class="line">  a[n] = x</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">sum(a)</div></pre></td></tr></table></figure></p><p>最终结果是<br>233168<br>然后我看了一下肖凯的解决方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x &lt;- 1:999</div><div class="line">sum(x[x %% 3 == 0 | x %% 5 == 0 ])</div></pre></td></tr></table></figure></p><p>大惊失色，我的思维还停留在刚学Python那会的水平，差距不是点吧点<br>我在留言下面看到了ygc，应该是Y叔的留言，那是在2013年10月26日的下午<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x &lt;- 1:999</div><div class="line">sum(ifelse(x%%3 &amp; x%%5, 0,x))</div></pre></td></tr></table></figure></p><p>随即他又给出了一行代码版本，完全的函数式编程范！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum(sapply(1:999, function(x) ifelse(x%%3 &amp; x%%5, 0, x)))</div></pre></td></tr></table></figure></p><p>前方的路真长<br>接着我又看到了一个奇特版本,思路也很简单，但是在R语言里面我想不到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sum(seq(3, 999, 3)) + sum(seq(5, 999, 5)) - sum(seq(15, 999, 15))</div></pre></td></tr></table></figure></p><p>我看了一下<a href="https://projecteuler.net/" target="_blank" rel="external">Project Euler</a> 上面现在有600多题，而且还在不断增长<br>是个学习的好机会，但是没有评判结果不行，我又在R-blogger上面发现很多答案<br><a href="https://www.r-bloggers.com/tag/project-euler/" target="_blank" rel="external">https://www.r-bloggers.com/tag/project-euler/</a><br>实在太开心了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Project Euler01&lt;br&gt;今天我无意间进入肖凯的博客，看到这样一篇文章&lt;br&gt;&lt;a href=&quot;http://xccds1977.blogspot.hk/2012/02/r_24.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;R语言编
      
    
    </summary>
    
      <category term="Project Euler" scheme="http://guoshipeng.com/categories/Project-Euler/"/>
    
    
      <category term="R" scheme="http://guoshipeng.com/tags/R/"/>
    
      <category term="编程" scheme="http://guoshipeng.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>R语言中选取多个文件夹中的文件合并到新的文件夹</title>
    <link href="http://guoshipeng.com/2017/11/13/15-multiple-files-into-one-by-R/"/>
    <id>http://guoshipeng.com/2017/11/13/15-multiple-files-into-one-by-R/</id>
    <published>2017-11-13T01:47:47.000Z</published>
    <updated>2017-11-13T02:05:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前的帖子解决了<a href="http://guoshipeng.com/2017/11/10/14-R-for-binding-colums/">在R语言中将多个同样的行列式文件合并起来</a>的问题<br>今天在处理TCGA数据时发现，数据下载后是放在单独的文件夹中的，几百个文件夹里面都有一个我们需要的文件，<br>需要把他们转移到新的文件中去，我看到perl语言的处理方式，应该R语言也可以完成<br>我这么做的原因就是，<br>在使用R语言处理数据时有个观点，我从两个人那边听到的，但是我现在还不能凝练：</p><ul><li>jimmy说，不要把数据导出为excel，然后下次又呆呆地导入，直接储存为”*.Rda”,要用的时候load即可，不需要来回读写</li><li>Y叔说，只要你还没有把图导出来打印，数据就是图，图就是数据，一切转换都有可能</li></ul><p>对我而言，最直接的原因就是，在R语言中处理数据，突然间中断使用其他语言的脚本来处理某个过程，这个状态很诡异，再怎么说R语言也是语言，<br>和其他语言比对perl比，处理数据顶多只是复杂和简单的关系，不应该是不能完成才对！</p><p>##建立测试数据，创建10个文件夹，同时在每个文件夹中创立10个新的文件</p><p>##经过试验我发现，dir不能批量生成，需要使用for循环，但是file可以批量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (i in 1:10) &#123;</div><div class="line">  dir.create(paste0(&quot;tmp_&quot;,i)) #创建10个文件夹</div><div class="line">  file.create(paste0(&quot;tmp_&quot;,i,&quot;/counts&quot;,i,&quot;.htq&quot;,seq(1:10))) #同时在每个文件夹中创立10个新的文件</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>查看数据,忽略TCGAbiolinks</p><blockquote><p>dir()<br>[1] “111.R”                  “112.R”                  “TCGAbiolinks.Rproj”<br>[4] “TCGAbiolinks_2.5.7.zip” “tmp_1”                  “tmp_10”<br>[7] “tmp_2”                  “tmp_3”                  “tmp_4”<br>[10] “tmp_5”                  “tmp_6”                  “tmp_7”<br>[13] “tmp_8”</p></blockquote><p>查看tmp_1文件夹中的内容</p><blockquote><p>dir(“tmp_1”)<br>[1] “counts1.htq1”  “counts1.htq10” “counts1.htq2”  “counts1.htq3”<br>[5] “counts1.htq4”  “counts1.htq5”  “counts1.htq6”  “counts1.htq7”<br>[9] “counts1.htq8”  “counts1.htq9”</p></blockquote><p>##任务：取每个文件夹中的第二个文件，就是名称以htq2结尾的文件</p><p>##并且把他们放到一个新的文件夹中去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">dir.create(&quot;tmp_all&quot;) #创建新的文件夹</div><div class="line">for (dirname in dir()[5:14])&#123;  </div><div class="line">  file &lt;- list.files(dirname,pattern = &quot;*.htq2&quot;) #找到对应文件夹中的内容，pattern可以是正则表达式</div><div class="line">  file.copy(paste0(dirname,&quot;/&quot;,file),&quot;tmp_all&quot;) #复制内容到新的文件夹</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其中dir()[5:14] 只是因为我自己的文件夹下有很多别的东西，这里是选取我想要的文件夹</p><blockquote><p>dir()[5:14]<br>[1] “tmp_1”  “tmp_10” “tmp_2”  “tmp_3”  “tmp_4”  “tmp_5”  “tmp_6”  “tmp_7”<br>[9] “tmp_8”  “tmp_9”</p></blockquote><p>我们看一下tmp_all是否已经有了文件</p><blockquote><p>dir(“tmp_all”)<br>[1] “counts1.htq2”  “counts10.htq2” “counts2.htq2”  “counts3.htq2”<br>[5] “counts4.htq2”  “counts5.htq2”  “counts6.htq2”  “counts7.htq2”<br>[9] “counts8.htq2”  “counts9.htq2”</p></blockquote><p>最终我发现，R语言处理起来也很简单！<br>有了一个隐蔽的博客真是好，随心所欲地记录。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前的帖子解决了&lt;a href=&quot;http://guoshipeng.com/2017/11/10/14-R-for-binding-colums/&quot;&gt;在R语言中将多个同样的行列式文件合并起来&lt;/a&gt;的问题&lt;br&gt;今天在处理TCGA数据时发现，数据下载后是放在单独的文件夹中
      
    
    </summary>
    
      <category term="生物信息" scheme="http://guoshipeng.com/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="R" scheme="http://guoshipeng.com/tags/R/"/>
    
      <category term="TCGA" scheme="http://guoshipeng.com/tags/TCGA/"/>
    
  </entry>
  
  <entry>
    <title>在R语言中将多个同样的行列式文件合并起来</title>
    <link href="http://guoshipeng.com/2017/11/10/14-R-for-binding-colums/"/>
    <id>http://guoshipeng.com/2017/11/10/14-R-for-binding-colums/</id>
    <published>2017-11-10T11:00:19.000Z</published>
    <updated>2017-11-13T02:13:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天在论坛学习TCGA-RNA seq的处理，看见这样一道题，<br><a href="http://www.biotrainee.com:8080/thread-603-1-1.html" target="_blank" rel="external">生信编程直播第四题：多个同样的行列式文件合并起来</a><br>想起当时R语言不熟练，根本不敢去看，今天尝试解决一下，原来如此简单。<br>这也是一个收集教案的过程，以后在课上的例子会生动需对，这一道题可以用来讲解for循环。<br>下载数据，解压到GSE48213_RAW，list.files用于列出文件夹下所包含的文件名<br>inner_join和merge函数一样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">library(dplyr)</div><div class="line">nameList &lt;- list.files(&quot;GSE48213_RAW/&quot;)</div><div class="line">matrix &lt;- read.table(paste0(&quot;GSE48213_RAW/&quot;,nameList[1]),header = T)</div><div class="line">for (i in 2:length(nameList))&#123;</div><div class="line">  matrix &lt;- inner_join(matrix,</div><div class="line">                      read.table(paste0(&quot;GSE48213_RAW/&quot;,nameList[i]),header = T),</div><div class="line">                      by=&quot;EnsEMBL_Gene_ID&quot;)</div><div class="line">&#125;</div><div class="line">save(matrix,file = &quot;56_cell_expression.Rda&quot;)</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天在论坛学习TCGA-RNA seq的处理，看见这样一道题，&lt;br&gt;&lt;a href=&quot;http://www.biotrainee.com:8080/thread-603-1-1.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;生信编程直播第四题：
      
    
    </summary>
    
      <category term="生物信息" scheme="http://guoshipeng.com/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="R" scheme="http://guoshipeng.com/tags/R/"/>
    
  </entry>
  
  <entry>
    <title>在Rstudio server中R的多版本切换</title>
    <link href="http://guoshipeng.com/2017/11/10/13-two-versions-of-R/"/>
    <id>http://guoshipeng.com/2017/11/10/13-two-versions-of-R/</id>
    <published>2017-11-10T06:28:42.000Z</published>
    <updated>2017-11-13T02:05:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>本次记录是为了自己查看：<br>在前一篇文章中，我自己编译了一个R</p><p>安装R version 3.4.2 Patched<br>下载地址:<br><a href="https://stat.ethz.ch/R/daily/" target="_blank" rel="external">https://stat.ethz.ch/R/daily/</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">tar -xf R-patched_2017-11-05.tar.gz</div><div class="line">sudo apt-get build-dep r-base-dev</div><div class="line">./configure --enable-R-shlib=yes</div><div class="line">make</div><div class="line">make check</div><div class="line">sudo make install</div></pre></td></tr></table></figure></p><p>在terminal中使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">which R</div></pre></td></tr></table></figure></p><blockquote><p>/usr/local/bin/R</p></blockquote><p>那么Rstudio会默认使用这个R</p><p>今天又安装了一个新的R，不是编译的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install r-base</div></pre></td></tr></table></figure></p><p>在终端中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/R</div></pre></td></tr></table></figure></p><p>可以打开这个新的版本<br>如果想要能够在Rstudio server中切换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/rstudio/rserver.conf</div></pre></td></tr></table></figure></p><p>在里面写入</p><blockquote><p>rsession-which-r=/usr/bin/R<br>也可以是<br>rsession-which-r=/usr/lib/R</p></blockquote><p>这时候重启Rstudio server ，新开一个session就可以看到版本已经改过来了<br>如果要回到之前的版本在/etc/rstudio/rserver.conf修改即可</p><blockquote><p>rsession-which-r=/usr/local/bin/R<br>也可以是<br>rsession-which-r=/usr/local/lib/R</p></blockquote><p>这个是修改Rstuido中默认的R版本，同时我们可以自定义每个用户的R默认版本，方法如下<br><a href="http://docs.rstudio.com/ide/server-pro/r-versions.html#r-versions" target="_blank" rel="external">http://docs.rstudio.com/ide/server-pro/r-versions.html#r-versions</a><br>内容真实丰富，暂时没搞懂，不过这个文档不错。</p><p>本文参考文章：<br><a href="https://support.rstudio.com/hc/en-us/articles/200486138-Using-Different-Versions-of-R" target="_blank" rel="external">https://support.rstudio.com/hc/en-us/articles/200486138-Using-Different-Versions-of-R</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本次记录是为了自己查看：&lt;br&gt;在前一篇文章中，我自己编译了一个R&lt;/p&gt;
&lt;p&gt;安装R version 3.4.2 Patched&lt;br&gt;下载地址:&lt;br&gt;&lt;a href=&quot;https://stat.ethz.ch/R/daily/&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
      <category term="生物信息" scheme="http://guoshipeng.com/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="R" scheme="http://guoshipeng.com/tags/R/"/>
    
      <category term="Ubuntu" scheme="http://guoshipeng.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu16.04-R3.4.2下安装clusterProfiler出现错误的解决过程</title>
    <link href="http://guoshipeng.com/2017/11/06/12-ubuntu-and-R/"/>
    <id>http://guoshipeng.com/2017/11/06/12-ubuntu-and-R/</id>
    <published>2017-11-06T10:17:40.000Z</published>
    <updated>2017-11-10T06:30:18.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171106/CCJlG5IGil.jpg" alt="mark"><br>最近在学习聚类分析，看了Y叔的一系列帖子，觉得clusterProfiler就是传说中一包走天下的神包<br>在windows和mac都安装成功，这是背景。<br><a id="more"></a><br>在Ubuntu16.04，R3.4.2(2017-09-28)下运行一下命令，发生错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">source(&quot;https://bioconductor.org/biocLite.R&quot;)</div><div class="line">biocLite(&apos;clusterProfiler&apos;)</div></pre></td></tr></table></figure></p><blockquote><p>** preparing package for lazy loading<br>Creating a new generic function for ‘append’ in package ‘BiocGenerics’<br>Creating a new generic function for ‘as.data.frame’ in package ‘BiocGenerics’<br>Creating a new generic function for ‘cbind’ in package ‘BiocGenerics’<br>Error : identical(as.call(parse(text = old_code)[[1L]]), body[[7L]][[3L]]) is not TRUE<br>Error in apply_hotfix73465(getGeneric(“cbind”)) :<br>  hotfix failed for generic function cbind()<br>Error : unable to load R code in package ‘BiocGenerics’<br>ERROR: lazy loading failed for package ‘BiocGenerics’</p><ul><li>removing ‘/home/shipeng/opt/biosoft/R/bioconductor/BiocGenerics’<br>ERROR: dependency ‘BiocGenerics’ is not available for package ‘S4Vectors’</li><li>removing ‘/home/shipeng/opt/biosoft/R/bioconductor/S4Vectors’<br>ERROR: dependencies ‘BiocGenerics’, ‘S4Vectors’ are not available for package ‘IRanges’</li><li>removing ‘/home/shipeng/opt/biosoft/R/bioconductor/IRanges’<br>ERROR: dependencies ‘BiocGenerics’, ‘IRanges’, ‘S4Vectors’ are not available for package ‘AnnotationDbi’</li><li>removing ‘/home/shipeng/opt/biosoft/R/bioconductor/AnnotationDbi’<br>ERROR: dependency ‘AnnotationDbi’ is not available for package ‘DO.db’</li><li>removing ‘/home/shipeng/opt/biosoft/R/bioconductor/DO.db’<br>ERROR: dependency ‘AnnotationDbi’ is not available for package ‘GO.db’</li><li>removing ‘/home/shipeng/opt/biosoft/R/bioconductor/GO.db’<br>ERROR: dependencies ‘AnnotationDbi’, ‘GO.db’ are not available for package ‘GOSemSim’</li><li>removing ‘/home/shipeng/opt/biosoft/R/bioconductor/GOSemSim’<br>ERROR: dependencies ‘AnnotationDbi’, ‘DO.db’, ‘GOSemSim’, ‘igraph’, ‘S4Vectors’ are not available for package ‘DOSE’</li><li>removing ‘/home/shipeng/opt/biosoft/R/bioconductor/DOSE’<br>ERROR: dependencies ‘DOSE’, ‘AnnotationDbi’, ‘GO.db’, ‘GOSemSim’ are not available for package ‘clusterProfiler’</li><li>removing ‘/home/shipeng/opt/biosoft/R/bioconductor/clusterProfiler’</li></ul></blockquote><p>如果仅仅运行这个代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">source(&quot;https://bioconductor.org/biocLite.R&quot;)</div><div class="line">biocLite()</div></pre></td></tr></table></figure></p><blockquote><p>Error : unable to load R code in package ‘BiocGenerics’<br>ERROR: lazy loading failed for package ‘BiocGenerics’</p><ul><li>removing ‘/home/shipeng/opt/biosoft/R/bioconductor/BiocGenerics’<br>ERROR: dependency ‘BiocGenerics’ is not available for package ‘S4Vectors’</li><li>removing ‘/home/shipeng/opt/biosoft/R/bioconductor/S4Vectors’<br>ERROR: dependencies ‘BiocGenerics’, ‘S4Vectors’ are not available for package ‘IRanges’</li><li>removing ‘/home/shipeng/opt/biosoft/R/bioconductor/IRanges’<br>ERROR: dependencies ‘BiocGenerics’, ‘IRanges’, ‘S4Vectors’ are not available for package ‘AnnotationDbi’</li><li>removing ‘/home/shipeng/opt/biosoft/R/bioconductor/AnnotationDbi’</li></ul></blockquote><p>追根溯源就是第一个<strong>‘BiocGenerics’</strong>没有安装成功<br>那我就来单独安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">source(&quot;https://bioconductor.org/biocLite.R&quot;)</div><div class="line">biocLite(&apos;BiocGenerics&apos;)</div></pre></td></tr></table></figure></p><p>报错信息如下：</p><blockquote><p>** preparing package for lazy loading<br>Creating a new generic function for ‘append’ in package ‘BiocGenerics’<br>Creating a new generic function for ‘as.data.frame’ in package ‘BiocGenerics’<br>Creating a new generic function for ‘cbind’ in package ‘BiocGenerics’<br>Error : identical(as.call(parse(text = old_code)[[1L]]), body[[7L]][[3L]]) is not TRUE<br>Error in apply_hotfix73465(getGeneric(“cbind”)) :<br>  hotfix failed for generic function cbind()<br>Error : unable to load R code in package ‘BiocGenerics’<br>ERROR: lazy loading failed for package ‘BiocGenerics’</p><ul><li>removing ‘/home/shipeng/opt/biosoft/R/bioconductor/BiocGenerics’</li></ul></blockquote><p>实际上如果biocLite(‘BiocGenerics’)装不上，那么内部缺少的依赖包不能通过biocLite(‘xxx’)这种形式安装<br>在R语言中执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sessionInfo()</div></pre></td></tr></table></figure></p><blockquote><p>R version 3.4.2 (2017-09-28)<br>Platform: x86_64-pc-linux-gnu (64-bit)<br>Running under: Ubuntu 16.04.3 LTS<br>Matrix products: default<br>BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.7.1<br>LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.7.1<br>locale:<br>[1] LC_CTYPE=en_US.UTF-8      LC_NUMERIC=C              LC_TIME=en_US.UTF-8<br>[4] LC_COLLATE=en_US.UTF-8    LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8<br>[7] LC_PAPER=en_US.UTF-8      LC_NAME=C                  LC_ADDRESS=C<br>[10] LC_TELEPHONE=C            LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C<br>attached base packages:<br>[1] parallel  stats    graphics  grDevices utils    datasets  methods  base<br>other attached packages:<br>[1] BiocInstaller_1.28.0 ggpubr_0.1.5        magrittr_1.5        ggplot2_2.2.1<br>[5] survival_2.41-3      dplyr_0.7.4          bindrcpp_0.2<br>loaded via a namespace (and not attached):<br>[1] Rcpp_0.12.13    compiler_3.4.2  plyr_1.8.4      bindr_0.1        tools_3.4.2<br>[6] tibble_1.3.4    gtable_0.2.0    nlme_3.1-131    lattice_0.20-35  pkgconfig_2.0.1<br>[11] rlang_0.1.2      Matrix_1.2-11    psych_1.7.8      yaml_2.1.14      knitr_1.17<br>[16] grid_3.4.2      glue_1.2.0      R6_2.2.2        foreign_0.8-69  scales_0.5.0<br>[21] splines_3.4.2    assertthat_0.2.0 mnormt_1.5-5    colorspace_1.3-2 lazyeval_0.2.1<br>[26] munsell_0.4.3</p></blockquote><p>也看不出什么名堂<br>google发现有人在bioconduct社区提问了相同的问题：<br><a href="https://support.bioconductor.org/p/101833/" target="_blank" rel="external">https://support.bioconductor.org/p/101833/</a></p><p>给出来三种解决方法：<br>第一，说尝试打开一个新的R session可以解决问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">R --vanilla</div></pre></td></tr></table></figure></p><p>照做后发现不能解决问题<br>有人在评论里面说</p><blockquote><p>Glad that installing R 3.4.2 Patched solved the problem</p></blockquote><p>但是这个版本我下载configure会报错(实际上是我不会编译R)就放弃了</p><p>我还看到有人说，</p><blockquote><p>sudo apt-get install r-bioc-biocgenerics</p></blockquote><p>这个命令可以解决问题<br>照做后显示我安装成功</p><blockquote><p>(Reading database … 185900 files and directories currently installed.)<br>Preparing to unpack …/r-bioc-biocgenerics_0.22.1-1ubuntu1_all.deb …<br>Unpacking r-bioc-biocgenerics (0.22.1-1ubuntu1) …<br>Setting up r-bioc-biocgenerics (0.22.1-1ubuntu1) …</p></blockquote><p>这时候我感到很高兴再来安装Y叔的包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">source(&quot;https://bioconductor.org/biocLite.R&quot;)</div><div class="line">biocLite(&apos;clusterProfiler&apos;)</div></pre></td></tr></table></figure></p><p>又报错：</p><blockquote><p>installing to /home/shipeng/opt/biosoft/R/bioconductor/S4Vectors/libs<br><strong> R</strong> inst<br>** preparing package for lazy loading<br>Error : package ‘BiocGenerics’ 0.22.1 was found, but &gt;= 0.23.3 is required by ‘S4Vectors’<br>ERROR: lazy loading failed for package ‘S4Vectors’</p><ul><li>removing ‘/home/shipeng/opt/biosoft/R/bioconductor/S4Vectors’</li></ul></blockquote><p>提示我安装的版本不够高<br>好的，现在我的问题可能就是<br><strong>安装版本高一点的R包，但是默认的biocLIte()是不行的</strong><br>我查到可以通过github来安装,并且有两种方式<br>第一种方式需要知道包在github的名字，不是很方便<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">install.packages(&quot;devtools&quot;)</div><div class="line">library(devtools)</div><div class="line">install_github(&quot;xxx&quot;)</div></pre></td></tr></table></figure></p><p>第二种方式方便一点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">install.packages(&quot;githubinstall&quot;)</div></pre></td></tr></table></figure></p><p>报错</p><blockquote><p>ERROR: configuration failed for package ‘curl’</p><ul><li>removing ‘/home/shipeng/opt/biosoft/R/bioconductor/curl’<br>Warning in install.packages :<br>installation of package ‘curl’ had non-zero exit status<br>ERROR: dependency ‘curl’ is not available for package ‘githubinstall’</li><li>removing ‘/home/shipeng/opt/biosoft/R/bioconductor/githubinstall’</li></ul></blockquote><p>提示我缺少curl,那我就装一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">install.packages(&quot;curl&quot;)</div></pre></td></tr></table></figure></p><p>报错</p><blockquote><p>ERROR: configuration failed for package ‘curl’</p><ul><li>removing ‘/home/shipeng/opt/biosoft/R/bioconductor/curl’<br>Warning in install.packages :<br>installation of package ‘curl’ had non-zero exit status<br>The downloaded source packages are in<br>  ‘/tmp/Rtmp0YZPFO/downloaded_packages’</li></ul></blockquote><p>还是没能解决,所以安装包的时候出现的问题，不能用R本身来解决！需要走其他的途径<br>网上说这个可以解决问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install libcurl4-openssl-dev</div></pre></td></tr></table></figure></p><p>安装完事后我又试了一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">install.packages(&quot;githubinstall&quot;)</div></pre></td></tr></table></figure></p><p>安装成功，那我就安装BiocGenerics试试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">library(githubinstall)</div><div class="line">githubinstall(&apos;BiocGenerics&apos;)</div></pre></td></tr></table></figure></p><blockquote><p>Select a number or, hit 0 to cancel.<br>1: Bioconductor/BiocGenerics  S4 generic functions for Bioconductor<br>2: lshep/BiocGenerics        alpha testing github<br>3: nturaga/BiocGenerics      test<br>4: schifferl/BiocGenerics</p></blockquote><p>试了第1个，第二个都失败<br>选择第三个后</p><blockquote><p><strong> help<br>*</strong> installing help indices<br><strong> building package indices</strong> testing if installed package can be loaded</p><ul><li>DONE (BiocGenerics)</li></ul></blockquote><p>成功!!!，我有开始安装Y叔的包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">source(&quot;https://bioconductor.org/biocLite.R&quot;)</div><div class="line">biocLite(&apos;clusterProfiler&apos;)</div></pre></td></tr></table></figure></p><blockquote><p>installing to /home/shipeng/opt/biosoft/R/bioconductor/S4Vectors/libs<br><strong> R</strong> inst<br>** preparing package for lazy loading<br>Error : package ‘BiocGenerics’ 0.23.0 was found, but &gt;= 0.23.3 is required by ‘S4Vectors’</p></blockquote><p>版本还是不够，这回真的没辙了<br>而使用biocLite()安装的报错信息我看不懂</p><blockquote><p>Error : identical(as.call(parse(text = old_code)[[1L]]), body[[7L]][[3L]]) is not TRUE<br>Error in apply_hotfix73465(getGeneric(“cbind”)) :<br>  hotfix failed for generic function cbind()</p></blockquote><p>问了Y叔，给了我一个帖子<a href="https://guangchuangyu.github.io/cn/2016/10/update-r-packages/" target="_blank" rel="external">无痛更新R包</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rvcheck::update_all()</div></pre></td></tr></table></figure></p><p>最后发现没有用</p><p>所以我来尝试一下帖子里说的安装R version 3.4.2 Patched<br>下载地址:<br><a href="https://stat.ethz.ch/R/daily/" target="_blank" rel="external">https://stat.ethz.ch/R/daily/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure</div></pre></td></tr></table></figure><p>报错</p><blockquote><p>error: –with-readline=yes (default) and headers/libs are not available</p></blockquote><p>上网查找<br><a href="https://stackoverflow.com/questions/20752307/error-in-install-previous-versions-of-r-on-ubuntu" target="_blank" rel="external">https://stackoverflow.com/questions/20752307/error-in-install-previous-versions-of-r-on-ubuntu</a><br>这里提供解决方案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install xorg-dev</div></pre></td></tr></table></figure></p><p><a href="https://cran.r-project.org/doc/manuals/R-admin.html#Essential-programs-and-libraries" target="_blank" rel="external">https://cran.r-project.org/doc/manuals/R-admin.html#Essential-programs-and-libraries</a><br>这个文档给出详细的解释</p><blockquote><p>Unless you do not want to view graphs on-screen (or use macOS) you need ‘X11’ installed, including its headers and client libraries. For recent Fedora/RedHat distributions it means (at least) RPMs ‘libX11’, ‘libX11-devel’, ‘libXt’ and ‘libXt-devel’. On Debian/Ubuntu we recommend the meta-package ‘xorg-dev’. If you really do not want these you will need to explicitly configure R without X11, using –with-x=no.</p></blockquote><p>运行后提示：</p><blockquote><p>R is now configured for x86_64-pc-linux-gnu<br>configure: WARNING: you cannot build info or HTML versions of the R manuals<br>configure: WARNING: you cannot build PDF versions of the R manuals<br>configure: WARNING: you cannot build PDF versions of vignettes and help pages</p></blockquote><p>启动R<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo R</div></pre></td></tr></table></figure></p><blockquote><p>R version 3.4.2 Patched (2017-11-05 r73673) – “Short Summer”<br>Copyright (C) 2017 The R Foundation for Statistical Computing<br>Platform: x86_64-pc-linux-gnu (64-bit)</p></blockquote><p>好了应该是按照成功了<br>尝试安装BiocGenerics<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">source(&quot;https://bioconductor.org/biocLite.R&quot;)</div><div class="line">biocLite(&apos;BiocGenerics&apos;)</div></pre></td></tr></table></figure></p><p>最终安装成功</p><blockquote><p><strong> help<br>*</strong> installing help indices<br><strong> building package indices</strong> testing if installed package can be loaded</p><ul><li>DONE (BiocGenerics)</li></ul></blockquote><p>可是我现在启动不了Rstudio</p><blockquote><p>ERROR Unable to find libR.so in expected locations within R Home direc</p></blockquote><p>把libR.so找到，复制指定目录下，最后发现rstudio成功，但是在rstudio所有R还是以前的版本<br>更改各种设置都不行，系统里面有两个R,删除掉其中一个<br>重新安装r<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">tar -xf R-patched_2017-11-05.tar.gz</div><div class="line">sudo apt-get build-dep r-base-dev</div><div class="line">./configure --enable-R-shlib=yes</div><div class="line">make</div><div class="line">make check</div><div class="line">sudo make install</div></pre></td></tr></table></figure></p><p>没有任何报错！！！<br><a href="https://bookdown.org/yihui/r-ninja/setup.html#r" target="_blank" rel="external">https://bookdown.org/yihui/r-ninja/setup.html#r</a><br>谢益辉说的这个无敌命令一次性解决依赖问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get build-dep r-base-dev</div></pre></td></tr></table></figure></p><p>在终端启动R<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">source(&quot;https://bioconductor.org/biocLite.R&quot;)</div><div class="line">options(BioC_mirror=&quot;http://mirrors.ustc.edu.cn/bioc/&quot;)</div><div class="line">biocLite(&apos;clusterProfiler&apos;)</div></pre></td></tr></table></figure></p><p>报错<br>说没有装上igraph<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install -y r-cran-igraph</div></pre></td></tr></table></figure></p><p>报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">E: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)</div><div class="line">E: Unable to lock the administration directory (/var/lib/dpkg/), are you root?</div></pre></td></tr></table></figure></p><p>加上root权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install -y r-cran-igraph</div></pre></td></tr></table></figure></p><p>安装完了之后，在r里面无法library<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ibrary(igragh)</div></pre></td></tr></table></figure></p><p>使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">install.packages(&quot;igraph&quot;)</div></pre></td></tr></table></figure></p><p>安装成功<br>再来安装Y叔的包<br>DOSE包安装失败<br>安装DOSE包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">devtools::install_github(&quot;GuangchuangYu/DOSE&quot;)</div></pre></td></tr></table></figure></p><p>报错</p><blockquote><p>Error in dyn.load(file, DLLpath = DLLpath, …) :<br>  unable to load shared object ‘/home/shipeng/opt/biosoft/R/bioconductor/stringi/libs/stringi.so’:<br>  libicui18n.so.57: cannot open shared object file: No such file or directory</p></blockquote><p>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">install.packages(&quot;stringi&quot;)</div></pre></td></tr></table></figure></p><p>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">biocLite(&apos;DOSE&apos;)</div></pre></td></tr></table></figure></p><p>成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">biocLite(&apos;clusterProfiler&apos;)</div></pre></td></tr></table></figure></p><p>成功！！！<br>测试数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">biocLite(&quot;ggridges&quot;)</div><div class="line">require(clusterProfiler)</div><div class="line">data(geneList)</div><div class="line">x &lt;- gseKEGG(geneList)</div><div class="line">ridgeplot(x,showCategory = 60)</div></pre></td></tr></table></figure></p><p>出图如下：这图出的不容易！！！！！<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171106/JLH0Fhme3i.png" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oy0a9ohwa.bkt.clouddn.com/blog/171106/CCJlG5IGil.jpg&quot; alt=&quot;mark&quot;&gt;&lt;br&gt;最近在学习聚类分析，看了Y叔的一系列帖子，觉得clusterProfiler就是传说中一包走天下的神包&lt;br&gt;在windows和mac都安装成功，这是背景。&lt;br&gt;
    
    </summary>
    
      <category term="生物信息" scheme="http://guoshipeng.com/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="R" scheme="http://guoshipeng.com/tags/R/"/>
    
      <category term="Ubuntu" scheme="http://guoshipeng.com/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>perl语言中文件句柄和参数设置的理解</title>
    <link href="http://guoshipeng.com/2017/10/18/11-perl-handle/"/>
    <id>http://guoshipeng.com/2017/10/18/11-perl-handle/</id>
    <published>2017-10-18T11:56:13.000Z</published>
    <updated>2017-10-18T12:02:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是过年期间的学习笔记，这段时间被标书虐的死去活来，休息的时候编辑了，这样提交完标书就可以学习RNA-seq了。<br><strong>文件句柄</strong> 这个概念光看字面完全不知所措，但是当我处理了一些数据时慢慢就能够理解。向别人解释一个概念最好的方法是类比，小时候听老师说地球就像鸡蛋，一下就理解了。目前我找到的能解释文件句柄的好类比就是：<br>摆渡船，没错，文件句柄就像摆渡船，他每次去对岸接一定人数的客人到这边来。而文件句柄的作用就是按照你的要求每次从文件中取出一部分数据供你处理。<br>下面举例子来理解：<br>我们要把几个序列格式化输出，要求每行60个字符。<br>原始文件如下：每一个&gt;开头的是一个序列文件，写到这里我突然间就有点伤感，这些东西我是知道的，为什么我还要写下来，给谁看呢，那么多的人在学python，只有少数人在用perl，Larry wall知道了是不是要很生气。我编辑的不是文案，我只是在拼凑破碎的心。<br><a id="more"></a><br>你可以看到每一个序列在每行的长度不一样。<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/13hgG9ifE8.png" alt="mark"><br>总共5个序列，想要让他们按照每一行60个字母呈现出来<br>我打开VIM，写下一下的代码，然后注释了一下。<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/3gJgI95JId.png" alt="mark"><br>运行程序后屏幕上显示：<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/IalE51e7lD.png" alt="mark"><br>说明成功了，那么这时候出现两个问题：</p><ul><li>如果我处理其他文本这么办？</li><li>如果我想每行50个字母，40个字母怎么办？<br>为了解决这个问题，需要引入<strong>参数</strong>这个概念：<br>在原有脚本的基础上，修改两个地方<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/j2KLBgf8kl.png" alt="mark"><br>这时候假如要实现50字母每行，那么就在终端输入：<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/CCED0m2DKl.png" alt="mark"><br>屏幕上显示：<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/B4KhgHkJDB.png" alt="mark"><br>这样我们就算成功了，此时我注意到我在一开始创建测试文件need_cahnge.fa时把scafald写错了，正确的单词应该是Scaffold，所以我准备使用pl程序把他修改好，并且输出到一个新的文件changed.fa<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/Ag51LE0EdL.png" alt="mark"><br>终端输入下列命令：<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/E27CcE5i75.png" alt="mark"><br>这个命令由四个部分组成：</li><li>第一个部分是perl，这是所有执行perl程序都需要的</li><li>第二个部分为perl程序的名称</li><li>第三个部分为第一个参数，就是输入的文件名</li><li>第四个部分为第二个参数，就是输出的文件名<br>最后得到的结果如下：<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/IDjI0j2F45.png" alt="mark"><br>看吧，名称已经换掉了。<br>我想我应该理解perl语言的文件句柄了。<br>实际上当我再次会看这个笔记的时候，我发现我陷入了怪圈，这个例子纯粹是为了将参数的作用<br>要替换一个文本里面的单词，为什么我不直接使用全局替换呢，整这么麻烦还沾沾自喜。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是过年期间的学习笔记，这段时间被标书虐的死去活来，休息的时候编辑了，这样提交完标书就可以学习RNA-seq了。&lt;br&gt;&lt;strong&gt;文件句柄&lt;/strong&gt; 这个概念光看字面完全不知所措，但是当我处理了一些数据时慢慢就能够理解。向别人解释一个概念最好的方法是类比，小时候听老师说地球就像鸡蛋，一下就理解了。目前我找到的能解释文件句柄的好类比就是：&lt;br&gt;摆渡船，没错，文件句柄就像摆渡船，他每次去对岸接一定人数的客人到这边来。而文件句柄的作用就是按照你的要求每次从文件中取出一部分数据供你处理。&lt;br&gt;下面举例子来理解：&lt;br&gt;我们要把几个序列格式化输出，要求每行60个字符。&lt;br&gt;原始文件如下：每一个&amp;gt;开头的是一个序列文件，写到这里我突然间就有点伤感，这些东西我是知道的，为什么我还要写下来，给谁看呢，那么多的人在学python，只有少数人在用perl，Larry wall知道了是不是要很生气。我编辑的不是文案，我只是在拼凑破碎的心。&lt;br&gt;
    
    </summary>
    
      <category term="生物信息" scheme="http://guoshipeng.com/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="Perl" scheme="http://guoshipeng.com/tags/Perl/"/>
    
  </entry>
  
  <entry>
    <title>perl语言中的字符串处理及排序</title>
    <link href="http://guoshipeng.com/2017/10/18/10-perl-string/"/>
    <id>http://guoshipeng.com/2017/10/18/10-perl-string/</id>
    <published>2017-10-18T11:44:47.000Z</published>
    <updated>2017-10-18T12:03:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>生物信息中的数据是以字符串形式呈现的，而perl语言90%的常用功能都在处理字符串上。所以我用了一些时间来学习这些处理字符串的手段。<br>比较重要的是index，substr，sort。</p><hr><p>首先是姐妹花index和rindex</p><ul><li><strong>index</strong> 从<strong>左边</strong>开始给出匹配字符的首字符位置</li><li><strong>rindex</strong> 从<strong>右边</strong>开始给出匹配字符的首字符位置</li></ul><p>注意:字符串的第一个位置为0<br>因为放假没办法用到服务器，所以perl语言的学习全是在mac电脑的终端完成的，其实和linux的终端完全一样。<br>下面我们设计了一个字符串，他有两个ATG，第一个ATG的A的位置为0，第二个ATG的A的位置为15，我们试一下:<br><a id="more"></a><br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/f7LDaf8mf9.png" alt="mark"><br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/HHc1L4Jd1i.png" alt="mark"><br>index和rindex有三个参数，第一个为要匹配的序列，第二个为目标字符串，第三个为开始匹配的位置（这个参数可选），当index匹配不到字符串时返回-1，例子中，第四个我们让他从第20个字符开始查找ATG，实际上没有20之后没有ATG了，所以返回值为-1</p><hr><p>既然可以查找字符串的位置，那么就自然想到截取一段序列，这时候要用到substr函数（其实这个概念我是从excel中知道的）<br>还是刚才那个序列，这次的目的是：提取出第二个ATG开始到最后一个TAA结束的序列：<br>思路就是知道要截取的序列，知道开始位置，知道截取长度就可以了。<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/HjBe6fGb6h.png" alt="mark"><br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/8h8Ii74906.png" alt="mark"><br>成功，这里substr也有三个参数，第一个为要匹配的序列，第二个为开始的位置，第三个为匹配的长度。</p><hr><p>这里我们自然而言地想到，可以截取出一段序列，那么将它替换成其他序列便是举手之劳：<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/FcmFlAA7Bm.png" alt="mark"><br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/a3JHCl9lJj.png" alt="mark"><br>实际上，这里的substr功能完全可以用正则表达式来实现，本次不作介绍。</p><hr><p>我们再看看处理的序列由碱基ATCG组成，对于生信工作者而言，把他转换成互补序列，反向序列，反向互补序列也应该成为正常需求。<br>其中反向序列，很好实现，用reverse函数即可，而互补序列用正则表达式的转换功能tr即可(正则表达式有三种模式，匹配，替换，转换)，反向互补序列把得到的互补序列reverse即可：<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/2ehmjgK2BA.png" alt="mark"><br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/iFifhDlbD7.png" alt="mark"></p><hr><p>那么我们再进一步，如何分割字符串呢？用split函数，实际上到了这里我们发现，perl语言中的命令完全就是日常用语，可能原因是，perl的发明者本身就是语言学家，那么设计语言时最好满足自然语义。<br>首先创建一个逗号分隔的字符串，然后尝试几种split分隔的模式及其返回的结果，学习perl语言光看书不行，必须要动手操作，在一个终端里面即时反馈，错了就调试。<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/ilI0aDb8iA.png" alt="mark"><br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/eeG7fAiAfI.png" alt="mark"><br>split的基本用法就是两个参数，返回的是数组，从\@split4可以看出来(4)，如果使用标量上下文返回的是数组元素的个数(1)，如果在末尾加上第三个参数，数字参数，就是限定最终切割的个数，如果是1就是不切割(2,3)，因为split返回的是数组，所以可以使用 []访问数组中的元素(6,7,8,9)，还可以同时命名三个标量，分别赋值见ABC。</p><hr><p>我们可以分割字符，也可以让他们再次连接在一起，而且可以定义连接的方式<br>使用join函数；实际上split和join就是相反的过程：<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/7AEefbacj3.png" alt="mark"><br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/2j7h4LAjkJ.png" alt="mark"></p><hr><p>此时，那些基本的求序列长度，去掉序最后一个字符，字符大小写转换，首字母大小写也需要一并掌握，实际上这时候会感觉很简单：<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/HifFD0L515.png" alt="mark"><br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/9hDh77gjFj.png" alt="mark"><br> 一开始序列长度为56，使用chop切掉末尾的T后只剩下56个，使用lc转换成小写，再使用uc转换成大写，使用lcfirst将首字母小写，使用ucfirst将首字母大写，最后尝试了另外的转换大小写的方式。</p><hr><p>##sort排序功能特别重要<br>perl提供了飞碟操作符：</p><ul><li>\$a &lt;=&gt; \$b 数字大小排序</li><li>\$a cmp \$b 字母顺序排序</li></ul><p>数字排序：<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/ABD2J7DEGK.png" alt="mark"><br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/lIAHi09AFd.png" alt="mark"><br>使用sort直接排序并不能按数字大小排序<br>字母排序：<br>借助字母的排序我测试了几种排序的方法以实现不同的效果<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/7I79j70L22.png" alt="mark"><br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/5i6g7gmi2m.png" alt="mark"><br>通过测试，我发现：</p><ul><li>sort和cmp效果相同(1-2)</li><li>四种忽略大小写的方法都可以实现相同的结果(3-6)</li><li>调换\$a和\$b的位置可以实现和reverse一样的功能(7-8)</li><li>对sort后的数组再用cmp排序可以实现按字母排序，并且大写字母在前(9)</li><li>我想怎么实现小写字母在前呢？在9的基础上，增加判断语句，当两个字母相同时，让小写字母在前面(10)</li></ul><hr><p>借助10的结果，学习一下\$a cmp \$b以及 \$a &lt;=&gt; \$b的功能，实际上他们是sort的一个参数<br>我们先看一下sort的用法</p><ul><li>直接使用,就是sort @array</li><li>自定义排序<br>sort {sub rule} @files<br>{}中就是排序的原则，\$a &lt;=&gt; \$b的意思就是按数字从小到大排序，\$a cmp \$b<br>就是按字母顺序排序，\$，\$b是系统的全局变量，我们记住有这样的用法即可，其中\$a cmp \$b以及 \$a &lt;=&gt; \$b是有返回值的。<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/85d6a824mg.png" alt="mark"><br>此时我们再来理解10的表达式，如果前面两个字母相同，那么返回值就是0，or和||的意思就是如果前面是假则执行后面的程序。<br>这种方法在hash的排序中也有广泛的使用。</li></ul><hr><p>##关于hash的排序<br>准确的说，hash是不能排序的，能够排序的是hash的键名和键值<br>我们先按照键名来排序：<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/6ifcD5795m.png" alt="mark"><br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/GD6bj4l53g.png" alt="mark"><br>实际上生活中更常见的是按照分数从大到小排序，用\$score{$a},表示键名对应的键值：<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/7ElHg1jceA.png" alt="mark"><br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/jje2mG8CK1.png" alt="mark"><br>我们发现，95分有两个人，我们希望当分数一样的安装名称的字母排序<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/JBAJ1H2DB4.png" alt="mark"><br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/a3Ll301CD6.png" alt="mark"></p><hr><p>我想我应该已经入门perl字符串的处理了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;生物信息中的数据是以字符串形式呈现的，而perl语言90%的常用功能都在处理字符串上。所以我用了一些时间来学习这些处理字符串的手段。&lt;br&gt;比较重要的是index，substr，sort。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;首先是姐妹花index和rindex&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;index&lt;/strong&gt; 从&lt;strong&gt;左边&lt;/strong&gt;开始给出匹配字符的首字符位置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rindex&lt;/strong&gt; 从&lt;strong&gt;右边&lt;/strong&gt;开始给出匹配字符的首字符位置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意:字符串的第一个位置为0&lt;br&gt;因为放假没办法用到服务器，所以perl语言的学习全是在mac电脑的终端完成的，其实和linux的终端完全一样。&lt;br&gt;下面我们设计了一个字符串，他有两个ATG，第一个ATG的A的位置为0，第二个ATG的A的位置为15，我们试一下:&lt;br&gt;
    
    </summary>
    
      <category term="生物信息" scheme="http://guoshipeng.com/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="Perl" scheme="http://guoshipeng.com/tags/Perl/"/>
    
      <category term="字符串" scheme="http://guoshipeng.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>可能是最好用的TCGA数据库GEPIA</title>
    <link href="http://guoshipeng.com/2017/10/18/09-GEPIA/"/>
    <id>http://guoshipeng.com/2017/10/18/09-GEPIA/</id>
    <published>2017-10-18T11:18:27.000Z</published>
    <updated>2017-10-18T11:26:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>听生信群里大神闲聊，说他自己的师弟做了个TCGA可视化工具，我就点开链接看了一下，不点开就算了，一点开不得了，<br>就像我手上的锤子手机，千万别用，用了就无法回头。</p><p>TCGA相关的数据库有很多，<br>但我最关心的功能只有三个，差异表达，生存分析，相关性分析，这也是我筛选课题的一个方向</p><ul><li>能够差异表达是前提</li><li>如果这时候还跟生存相关，那就锦上添花了，</li><li>通过相关性分析找出他的朋友们，所谓物以类聚，看看这个人的朋友基本上就知道他是什么样子的人，</li></ul><blockquote><p>有一个恐怖的传说一直让我后背冒汗心里起火：你的工资是跟你密切交往的6个朋友的平均值，朋友居然重要到这个层面。<br><a id="more"></a></p></blockquote><p>好了，不鬼扯，我们简单介绍一下这个数据库GEPIA（Gene Expression Profilling Interactive Analysis），翻译一下应该是<br>基因表达谱数据动态分析。<br> <a href="http://gepia.cancer-pku.cn/index.html" target="_blank" rel="external">http://gepia.cancer-pku.cn/index.html</a><br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/6kEAhd4C6C.png" alt="mark"><br>这个数据库是北京大学开发的，没有发文章，没有发文章。</p><blockquote><p>This tool is developed by Zefang Tang, Chenwei Li and Boxi Kang of Zhang Lab, Peking University.</p></blockquote><p>我要学学宝剑叔叔右哉，先拟定一个让你痛心的场景，蓝后一步一步帮你解决, 这可能有助于我们直接解决问题。<br>假设，</p><blockquote><p>你现在已经研二了，之前放浪形骸，行散神也散，现在木有课题，木有鱼丸，明年要毕业了，蓝后没有管你<br>也没有男女朋友，没有大师兄，没有沙师弟，你该怎么办呢？</p></blockquote><p>我们可以这样，先找出某个特定癌症中跟生存最相关的一串基因，再来慢慢筛选，正好GEPIA有这个功能。<br>先点击一下Survival Analysis，依次点击<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/B46k1BLEiI.jpg" alt="mark"><br> 用下面的方法也是一样的。还要简单一点。<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/D444m67C1f.jpg" alt="mark"><br> 点击list会出现下面的结果，可以查询，可以翻页，可以一个个复制粘贴用以前讲的方法做GO分析，KEGG分析，互作分析。<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/83Egf4JDFa.jpg" alt="mark"><br> 这里我们直接选择VADC1来看看，首先我们检查一下这个基因分生存分析图究竟是什么样子，点击它<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/achcfah8K1.jpg" alt="mark"><br>这时候相当于进入了单基因入口，这里面给出了这个基因概括，说是线粒体膜的主要组成成分，也跟铁的转运相关，我觉得都是热门方向<br>如果这个领域你hold不住，就返回去再换一个基因点进来，最右边图我觉得很直观，绿色代表VDAC1在正常组织的表达，红色代表在肿瘤组织中的表达<br>可能这张图看不出啥特殊，我举个例子，<br>  <img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/3cAF8ACG1g.jpg" alt="mark"><br>A基因几乎只在乳腺表达，而且在乳腺癌中明显高表达<br>B基因在全身广泛表达，但是表达风度不高，而在乳腺癌中表达显著提高</p><p>好了页面往下拉就可以看到这个基因在多个癌症癌和癌旁的表达情况，我们可以看出他在乳腺癌中是高表达的<br>但是在其他许多癌症中也明显差异表达，这张表不会让你漏掉其他癌症，如果恰巧实验室有人在做那个癌症，你就可以跟他合伙搞一搞嘛。<br>因为你没有人管，没有大师兄，没有沙师弟，你还有什么选择？<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/6046HdieGh.jpg" alt="mark"><br>此外，你是可以选择呈现方式的，按照如下步骤操作可以得到漂亮的癌和癌旁的表达图<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/3C2ka95ejL.jpg" alt="mark"><br> 点击plot之后是这个样子的，可以下载，可以直接放在文章里面<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/126laka1EL.jpg" alt="mark"><br>返回一开始的界面，往下面翻一翻就会看到和这个基因表达类似的基因<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/hiAG9akje5.png" alt="mark"><br> 哎呦歪，里面HNRNPAB就是核内不均一核糖核蛋白家族成员，他可是要调控RNA的可变剪切的，许多LNCRNA作pulldown后就会拉下这个家族的成员<br>相关的文章从SCIENCE，CELL到ONCOTARGETS都有。</p><p> 但是我们差点忘了进来是干什么的，我们是来看生存分析的。依次操作。<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/53blbH9iL7.jpg" alt="mark"><br> 点击plot就会得到下面的图<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/9gKGi2JegI.jpg" alt="mark"><br>这个图真的是漂亮，一点都不含糊，好了这时候课题基本上就有苗头了</p><blockquote><p>VDAC1以暂时不知道的原因升高导致乳腺癌的发生，而乳腺癌患者高表达VADAC1的患者低生存，</p></blockquote><p>而临床医生做科研不外乎诊和疗</p><ul><li>从诊治的角度来说，这个基因表达水平对诊断乳腺癌有没有帮助？</li><li>从治疗的角度来说，既然高表达低生存，那么有没有可能设计抗体来治疗乳腺癌呢？</li></ul><p>当然那个是转化医学，在这之前就是基础医学<br>从研究的角度来看：</p><ul><li>这个基因高表达的原因是什么？表观遗传相关么，突变么，转录激活么，翻译修饰么，搞清楚就已经不容易了。<br>我们试一试表观遗传有没有影响，在UCSC数据库中打开VDAC1，我的妈呀，他的启动子区域这么汹涌澎湃的H3K27ac修饰，说明他的表达量本身就很高，不大可能是个坏分子，要么就是他在癌中突变了，要么就是他启动子在癌症中被过度激活了，我只是说可能<br>那么就会有个子课题产生：<blockquote><p>H3K27ac组蛋白乙酰化修饰促使VDAC1基因启动子激活从而升高其表达</p></blockquote></li></ul><p><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/8Lj44e9jbc.jpg" alt="mark"></p><ul><li>另外一个问题，这个基因在乳腺癌中的功能是什么？<br>可以尝试用生物信息学找到共表达的基因，之前已经列出来了，再去预测他可能有什么功能，<br>也可以直接构建慢病毒shRNA敲减后看看他的表型，<br>可是这不是你想要的，我们需要的是短平快，怎么办呢？查文献，<br>恰好我刚知道那个写过Hallmars of Cancer这篇文章老爷爷Weinberg在nature发表了一篇文章，时间是2017年3月30日，他们找到了乳腺癌中一个新的抑癌基因<br>叫做LACTB，他能够调控脂质代谢抑制乳腺癌，LACTB是一个线粒体相关的蛋白，VDAC1也是一个线粒体相关的蛋白，他们之间可能有联系么？<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/clE4FjED4C.png" alt="mark"><br>他们的联系可能多种多样，我们尝试用现成的工具看一下，相关性分析<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/GGg3KJ8CE9.jpg" alt="mark"><br>点击plot试一下<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/Gff0B2lCmH.png" alt="mark"><br>居然他们还有相关性，欢天喜地庆丰收，毕业在望。可是他们他们应该表达呈负相关才合理呀，<br>这么来把这些结果整合到一起呢？VDAC1和LACTB相关，抑制癌症的产生，蓝后不知怎么的他的启动子就过度活化了<br>然后他就促发了癌症？<br>我觉得自己都说服不了，我们还是换一种思路吧，用string数据库来看一看<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/IcLkm0k9iA.jpg" alt="mark"><br>VDAC1居然跟BAX，BCL2L1相关，表明其可能跟细胞的凋亡相关</li></ul><hr><p><strong>好了最终的课题就是</strong><br>H3K27ac修饰使VDAC1的启动子过度乙酰化促进其表达从而抑制细胞凋亡促进乳腺癌的发展。<br>我觉得这时候真的可以搞一搞了，什么，你没有shRNA？<br>不是说了跟别人合作么，你怎么又搞忘了。<br>蓝后检索一下VDAC1和乳腺癌的文章，发现少之又少，开始吧。<br>这个过程中好像文献阅读并不重要，但是不要忘了LACTB是Weinberg文章里面的<br>LACTB在乳腺癌中的表达和调控还没有研究呢，上面那个课题要是实在弄不好，就换这一个吧。<br>Note: 表观遗传那一块我是不严谨的，应该选乳腺的数据看看修饰，ENCODE数据库就支持。<br>蓝后，我觉得科研结果的呈现最基本的要求就是</p><p>##自洽<br>四个字就是自圆其说，不要前后矛盾，你自己构建了一个体系，一定要让自己信服。<br>自己都不相信的东西还想让别人相信，你把我当什么了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听生信群里大神闲聊，说他自己的师弟做了个TCGA可视化工具，我就点开链接看了一下，不点开就算了，一点开不得了，&lt;br&gt;就像我手上的锤子手机，千万别用，用了就无法回头。&lt;/p&gt;
&lt;p&gt;TCGA相关的数据库有很多，&lt;br&gt;但我最关心的功能只有三个，差异表达，生存分析，相关性分析，这也是我筛选课题的一个方向&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能够差异表达是前提&lt;/li&gt;
&lt;li&gt;如果这时候还跟生存相关，那就锦上添花了，&lt;/li&gt;
&lt;li&gt;通过相关性分析找出他的朋友们，所谓物以类聚，看看这个人的朋友基本上就知道他是什么样子的人，&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;有一个恐怖的传说一直让我后背冒汗心里起火：你的工资是跟你密切交往的6个朋友的平均值，朋友居然重要到这个层面。&lt;br&gt;
    
    </summary>
    
      <category term="生物信息" scheme="http://guoshipeng.com/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="TCGA" scheme="http://guoshipeng.com/tags/TCGA/"/>
    
      <category term="数据库" scheme="http://guoshipeng.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="GEPIA" scheme="http://guoshipeng.com/tags/GEPIA/"/>
    
  </entry>
  
  <entry>
    <title>Linux 安装后要做的事</title>
    <link href="http://guoshipeng.com/2017/10/18/08-linux-apply/"/>
    <id>http://guoshipeng.com/2017/10/18/08-linux-apply/</id>
    <published>2017-10-18T11:05:08.000Z</published>
    <updated>2017-10-18T11:26:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>组装了服务器，又装上了系统，会使用编辑器，我马上就想开始RNA-seq的练习，但是在这之前，有一些事情需要完成。<br>首先要知道如何进入linux的终端，当我没说。</p><p>##知道基本的linux命令</p><blockquote><p>ls,pwd,cd, cat,less,vim</p></blockquote><ul><li>pwd查看当前目录</li><li>ls查看目录下的文件</li><li>cd 切换目录，tab键可以自动补齐<br>详细的可以读一读生信菜鸟的帖子<a href="http://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&amp;mid=2247483957&amp;idx=1&amp;sn=302a35c3ad63043fd6eb57e76c0ca1e1&amp;chksm=9b48428eac3fcb98c8608abef97c5dd854026df414d2f54fb8b50f7efba3651d930dae2221b1&amp;mpshare=1&amp;scene=1&amp;srcid=0205wFsQKdoRTniFUrV6qcFU#rd" target="_blank" rel="external">教你如何轻松入门Linux</a>，我把它放在了阅读原文里面。<a id="more"></a>##配置SSH<br>虽然我为linux配置了一块屏幕，实际上工作中并不需要，我们用笔记本ssh到服务器，然后直接在自己的笔记本电脑上操作就行了<br>#号表示root权限，$表示普通权限，这两个符号不需要输入。切换root 和普通用户使用命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">su root  #普通转root</div><div class="line">su 用户名 #root转回普通用户，注意大部分时间是在用普通权限，不需要使用root账户分析数据，因为linux认为权限越大，责任越大，你使用root删除资料是没有人提醒你的，删了就是删了。</div></pre></td></tr></table></figure></li></ul><p>终端中输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># vim /etc/ssh/sshd_config</div></pre></td></tr></table></figure></p><p>上一次已经说了vim的基本使用，把下面文字前面的#号去掉</p><ul><li>Port 22</li><li>Protocol 2<br>保存退出，再输入：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># /etc/init.d/sshd restart</div></pre></td></tr></table></figure></li></ul><p>使用命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig</div></pre></td></tr></table></figure></p><p>找到类似于192.168这样的地址,然后记住自己的账户名和登录密码<br>使用putty或者xshell即可使用笔记本远程登录自己的服务器<br>此时服务器可以不用关机，屏幕也可以不要了。<br>注意，这里的远程登录，范围大小只是路由器的辐射范围，不能异地远程登录，如果想要实现异地远程登录，即在家使用实验室的服务器，需要服务器有固定IP，而固定IP很贵，买不起，如果没有可以尝试用下面的方法实现。</p><blockquote><p>路由器端口转发</p></blockquote><p>具体过程可以查询解决方案，这时候要注意，一旦路由器断电，或者重启，路由器会获得一个新的IP，这时候需要重新设置，才能继续使用。<br>如果需要再服务器和windows电脑上交换文件，推荐使用windows端的winscp软件，很好用。</p><p>##修改SELinux配置<br>打开SElinux会导致一些生物信息软件安装不了，所以将他关闭<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"># vim /etc/selinux/config</div></pre></td></tr></table></figure></p><p>输入下面文字：</p><ul><li>SELINUX=disabled<br>##安装GCC<br>我们安装的Centos6.5里面含有的是低版本的GCC，而有一些生物信息软件的安装需要高版本的GCC，这一次我们的任务是安装一个高版本的GCC，并且与系统自带的GCC共存。<br>GCC是个编译工具。Linux系统下的GCC（GNU C Compiler）是GNU推出的功能强大、性能优越的多平台编译器，是GNU的代表作品之一。gcc是可以在多种硬体平台上编译出可执行程序的超级编译器，其执行效率与一般的编译器相比平均效率要高20%~30%。其实到目前为止我也搞不清楚，但是我会装，会用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /opt/biosoft /opt/sysoft/ #使用root权限在opt下创建biosoft和sysoft文件夹，以后大部分软件安装在biosoft里面，本次高版本GCC软件安装在syssoft文件夹</div><div class="line">sudo chmod 1777 /opt/biosoft /opt/sysoft/ #使用root修改文件夹的权限</div><div class="line">wget http://mirrors-usa.go-parts.com/gcc/releases/gcc-4.9.3/gcc-4.9.3.tar.bz2 -P ~/software/  #下载高版本GCC到software文件夹</div><div class="line">tar jxf ~/software/gcc-4.9.3.tar.bz2  #打包解压</div><div class="line">cd gcc-4.9.3/ #转到这个目录</div><div class="line">./contrib/download_prerequisites# 下载相应的依赖软件</div><div class="line">sudo yum install glibc-devel.i686</div><div class="line">mkdir ../gcc-build</div><div class="line">cd ../gcc-build</div><div class="line">../gcc-4.9.3/configure --prefix=/opt/sysoft/gcc-4.9.3 --enable-multilib --with-system-zlib</div><div class="line">make -j 8  #8线程编译</div><div class="line">make install</div><div class="line">cd ../ &amp;&amp; rm gcc-build/ gcc-4.9.3/ -rf</div><div class="line">echo &apos;export PKG_CONFIG_PATH=/opt/sysoft/gcc-4.9.3/lib/pkgconfig:$PKG_CONFIG_PATH&apos; &gt;&gt; ~/.bashrc.gcc</div><div class="line">echo &apos;export LD_LIBRARY_PATH=/opt/sysoft/gcc-4.9.3/lib64:/opt/sysoft/gcc-4.9.3/lib:$LD_LIBRAR\ Y_PATH&apos; &gt;&gt; ~/.bashrc.gcc</div><div class="line">echo &apos;export C_INCLUDE_PATH=/opt/sysoft/gcc-4.9.3/include:$C_INCLUDE_PATH&apos; &gt;&gt; ~/.bashrc.gcc</div><div class="line">echo &apos;PATH=/opt/sysoft/gcc-4.9.3/bin/:$PATH&apos; &gt;&gt; ~/.bashrc.gcc</div><div class="line">source ~/.bashrc.gcc</div></pre></td></tr></table></figure></li></ul><p>##安装Python 2.7.11 版本<br>有的软件执行需要Python<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">wget https://www.python.org/ftp/python/2.7.11/Python-2.7.11.tgz -P ~/software/</div><div class="line">tar zxf ~/software/Python-2.7.11.tgz</div><div class="line">cd Python-2.7.11/</div><div class="line">./configure --prefix=/opt/sysoft/Python-2.7.11/</div><div class="line">make -j 8</div><div class="line">make install</div><div class="line">cd .. &amp;&amp; rm Python-2.7.11/ -rf</div><div class="line">echo &apos;PATH=$PATH:/opt/sysoft/Python-2.7.11/bin/:$PATH&apos; &gt;&gt; ~/.bashrc</div><div class="line">source ~/.bashrc</div></pre></td></tr></table></figure></p><p>##安装pip，用于安装Python需要的依赖软件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">wget https://pypi.python.org/packages/45/5e/79ca67a0d6f2f42bfdd9e467ef97398d6ad87ee2fa9c\ 8cdf7caf3ddcab1e/setuptools-23.0.0.tar.gz -P ~/software/Python_modules/</div><div class="line">tar zxf ~/software/Python_modules/setuptools-23.0.0.tar.gz</div><div class="line">cd setuptools-23.0.0/</div><div class="line">/opt/sysoft/Python-2.7.11/bin/python setup.py install</div><div class="line">cd .. &amp;&amp; rm setuptools-23.0.0 -rf</div><div class="line">wget https://pypi.python.org/packages/e7/a8/7556133689add8d1a54c0b14aeff0acb03c64707ce1\ 00ecd53934da1aa13/pip-8.1.2.tar.gz -P ~/software/Python_modules/</div><div class="line">tar zxf ~/software/Python_modules/pip-8.1.2.tar.gz</div><div class="line">cd pip-8.1.2/</div><div class="line">/opt/sysoft/Python-2.7.11/bin/python setup.py install</div><div class="line">cd .. &amp;&amp; rm pip-8.1.2 -rf</div></pre></td></tr></table></figure></p><p>##CentOS下安装软件的常用方法<br>这部分整理自笔记，来源不清楚，也可以看完这部分内容再去完成上面的操作，主要是帮助立即。</p><ul><li>1.一种是软件的源代码，需要自己动手编译它。这种软件安装包通常是用gzip压缩过的tar包（后缀为.tar.gz）。</li><li>2.另一种是软件的可执行程序，只要安装它就可以了。这种软件安装包通常被是一个RPM包（Redhat Linux Packet Manager，就是Redhat的包管理器），后缀是.rpm。<br>##对于需要编译的第一种，分两个部分：<br>###第一部分：.tar.gz<br>首先，将安装文件拷贝至你的目录中。例如，如果你是以root身份登录上的，就将软件拷贝至/root中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#cp filename.tar.gz /root</div></pre></td></tr></table></figure></li></ul><p>由于该文件是被压缩并打包的，所以，应对其解压缩。命令为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#tar xvzf filename.tar.gz</div></pre></td></tr></table></figure></p><p>执行该命令后，安装文件按路径被解压缩在当前目录下。用ls命令可以看到解压缩后的文件。通常在解压缩后产生的文件中，有名为”INSTALL”的文件。该文件为纯文本文件，详细讲述了该软件包的安装方法。<br>对于多数需要编译的软件，其安装的方法大体相同。执行解压缩后产生的一个名为configure的可执行脚本程序。它是用于检查系统是否有编译时所需的库，以及库的版本是否满足编译的需要等安装所需要的系统信息。为随后的编译工作做准备。命令为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#./configure</div></pre></td></tr></table></figure></p><p>如果检查过程中，发现有错误，configure将给予提示，并停止检查。你可以跟据提示对系统进行配置。再重新执行该程序。检查通过后，将生成用于编译的MakeFile文件。此时，可以开始进行编译了。编译的过程视软件的规模和计算机的性能的不同，所耗费的时间也不同。命令为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#make (make -j 4 这是以四线程来编译)</div></pre></td></tr></table></figure></p><p>成功编译后，键入如下的命令开始安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#make install (sudo make install)</div></pre></td></tr></table></figure></p><p>安装完毕，应清除编译过程中产生的临时文件和配置过程中产生的文件。键入如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#make clean</div><div class="line">#make distclean</div></pre></td></tr></table></figure></p><p>至此，软件的安装结束</p><p>###第二部分<br>1.首先，使用tar -xzvf来解开这个包，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#tar -xzvf apache_1_3_6_tar.gz</div></pre></td></tr></table></figure></p><p>这样就会在当前目录中创建了一个新目录(目录名与.tat.gz包的文件名类似），用来存放解压了的内容。如本例中就是apache_1.3.6<br>2.进入这个目录，再用ls命令查看一下所包含的文件，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#cd apache_1.3.6</div><div class="line">#ls</div></pre></td></tr></table></figure></p><p>你观察一下这个目录中包含了以下哪一个文件：configure、Makefile还是Imake。</p><ul><li><p>1.如果是configure文件,就执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#./configure</div><div class="line">#make</div><div class="line">#make install</div></pre></td></tr></table></figure></li><li><p>2.如果是Makefile文件,就执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#make</div><div class="line">#make install</div></pre></td></tr></table></figure></li><li><p>3.如果是Imake文件,就执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#xmkmf</div><div class="line">#make</div><div class="line">#make install</div></pre></td></tr></table></figure></li></ul><p>make原理是执行一个叫(所生成的)Makefile文件里的指令，make的基本用处是自动根据makefile里的指令来编译源文件。它还可以用来做比如安装软件，卸载软件等事情，但前提是作者在makefile里写了。比如makefile里有这么些内容：<br>install : &lt; commands &gt;<br>然后用make install的话，make程序就会按照上面install：后面的指令&lt; commands &gt;执行安装，uninstall也是一样的道理，大部分的作者会写有卸载的部分，这时只要简单地执行make unistall就可以，如果作者懒没有写，那就只有根据make install中的步骤，看它把什么文件拷到哪去了，然后分别手动删除。<br>还有关键的一点是，编译安装完成后，不要删除源代码，不然就算作者写了unnistall目标，你也没有makefile可以执行了。<br>3.如果没有出现什么错误提示的话，就搞定了。至于软件安装到什么地方，通常会在安装时出现。否则就只能查阅一下README。</p><p>##第二种：.rpm<br> RPM是Red Hat公司随Redhat Linux推出了一个软件包管理器，通过它能够更加轻松容易地实现软件的安装。<br>将安装文件拷贝至你的目录中/usr/src。然后使用rpm来安装该文件。命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#rpm -ivh filename.i386.rpm</div></pre></td></tr></table></figure></p><p>rpm将自动将安装文件解包，并将软件安装到缺省的目录下。并将软件的安装信息注册到rpm的数据库中。</p><ul><li><p>1.安装软件：执行rpm -ivh rpm包名，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#rpm -ivh apache-1.3.6.i386.rpm</div></pre></td></tr></table></figure></li><li><p>2.升级软件：执行rpm -Uvh rpm包名。</p></li><li>3.反安装：执行rpm -e rpm包名。</li><li>4.查询软件包的详细信息：执行rpm -qpi rpm包名</li><li>5.查询某个文件是属于那个rpm包的：执行rpm -qf rpm包名</li><li>6.查该软件包会向系统里面写入哪些文件：执行 rpm -qpl rpm包名<br>##终于可以开始RNA-seq分析啦！！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;组装了服务器，又装上了系统，会使用编辑器，我马上就想开始RNA-seq的练习，但是在这之前，有一些事情需要完成。&lt;br&gt;首先要知道如何进入linux的终端，当我没说。&lt;/p&gt;
&lt;p&gt;##知道基本的linux命令&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ls,pwd,cd, cat,less,vim&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;pwd查看当前目录&lt;/li&gt;
&lt;li&gt;ls查看目录下的文件&lt;/li&gt;
&lt;li&gt;cd 切换目录，tab键可以自动补齐&lt;br&gt;详细的可以读一读生信菜鸟的帖子&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMDkxODM1Ng==&amp;amp;mid=2247483957&amp;amp;idx=1&amp;amp;sn=302a35c3ad63043fd6eb57e76c0ca1e1&amp;amp;chksm=9b48428eac3fcb98c8608abef97c5dd854026df414d2f54fb8b50f7efba3651d930dae2221b1&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0205wFsQKdoRTniFUrV6qcFU#rd&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;教你如何轻松入门Linux&lt;/a&gt;，我把它放在了阅读原文里面。
    
    </summary>
    
      <category term="生物信息" scheme="http://guoshipeng.com/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="Linux" scheme="http://guoshipeng.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>编辑器之神VIM的使用及配置</title>
    <link href="http://guoshipeng.com/2017/10/17/07_vim/"/>
    <id>http://guoshipeng.com/2017/10/17/07_vim/</id>
    <published>2017-10-17T12:59:01.000Z</published>
    <updated>2017-10-18T11:00:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>做生信要写代码，写代码就需要编辑器，在linux系统下有一款编辑器不能被忽略，就是VIM，江湖人称编辑器之神。当然，在一堆程序员里面千万不要讨论语言的好坏，也不能突然冒一句perl是世界上最好的脚本语言，不能，千万不能，要不然死的很难看。</p><p>所以讨论编辑器时也不能随便说哪个最好，人们常说vim是编辑器之神，继而又说他的对手emacs是神的编辑器。绕来绕去就是为了一个名分，所谓树争一身皮，编辑器争一口气。<br>VIM用好了以后的状态是这样子的：</p><blockquote><p>写过程序的人都知道，编程的时候双手大部分时间都放在键盘上，或编码、或插入、或移动、或定位、或查找，这种连续操作的时间和频率远远大于阅读、翻页、设置字体、摆弄样式等文案工作，而二者往往产生很多停顿和间隙，而编程时的停顿是非常影响编程效率的，所以 Vim 的设计理念就是通过模式的转换、命令的组合和不计其数的插件，保证程序员在编程的过程中，双手尽可能保留在键盘中央的区域，并且，<strong>不需要鼠标</strong>。<br><a id="more"></a></p></blockquote><p>大多人看不起VIM的原因可能有一个：VIM上手容易，但学习曲线陡峭，很多人没有学会就放弃了。这不是我说的，是池建强老师说的。VIM的故事和详细用法可以查看池建强老师写的VIM系列，最终他把这个系列写成了一篇长文，<a href="http://mp.weixin.qq.com/s?__biz=MjM5ODQ2MDIyMA==&amp;mid=2650712546&amp;idx=1&amp;sn=c4db99547b75d6001b3cfaa6cbc0e715&amp;scene=21#wechat_redirect" target="_blank" rel="external">说，谁才是最帅的编程工具？</a>十分精彩，我觉得可以去读一读。微信不能外部链接，我把他放在了阅读原文里面。<br>VIM内置在linux系统下，在命令行输入 vim 然后enter键，就可以看到vim<br>vim的上手很简单，他有四种模式</p><ul><li>普通模式：Vim 启动后的默认模式，用来移动光标、删除文本、覆盖输入文本、恢复操作、粘贴文本等等。</li><li>插入模式：输入 i 或 a 进入插入模式，在这个模式下敲击键盘会往文字缓冲区增加文字，相当于普通编辑器的编辑模式。</li><li>可视模式：选择文本，可以行选、块选和依次选择，选择后可以进行复制、删除、排序等操作。</li><li>命令模式：执行内部和外部命令，通过「: / ? !」可以进入命令模式，分别对应的是：执行内部命令、向上或向下搜索、执行外部命令。</li></ul><p>假设我们写个名字叫11的perl程序，直接在命令行输入vim 11.pl enter键就OK了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim 11.pl</div></pre></td></tr></table></figure></p><p>接着我们按一下a或者i就进入插入模式，这时候在就可以通过键盘随便输入了，你打字的时候看一下左下方会有insert字样<br>假设我们现在已经写完程序，想要保存退出怎么办呢？<br>按esc键切换到命令行模式，同时按shift+：，就是shift键和冒号一起按，这时候左下角会出现冒号标志<br>输入wq就是保存退出<br>输入q！就是不保存直接退出<br>注意，如果操作不了，一定要确定正在使用的是英文输入法<br>这样就已经学完了</p><p>这时候要想到vim是效率神器，而且不需要鼠标就可以方便的复制粘贴，跳跃，所以接下来会有很多命令要学，我自己掌握的也不好，就不献丑了，至少我已经在用了，perl程序全是使用vim写的。</p><p>现在有个问题就是vim不好看，虽然不需要鼠标，全键盘操作，但我觉得界面太丑，没有电影里面那种花花绿绿代码齐发的感觉，现在我知道那个叫语法高亮，所以我又查了一下vim的配置。</p><blockquote><p><strong>很多时候长大了那些执念就是为了完成小时候未完成的心愿。</strong></p></blockquote><p>##VIM的配置<br>切换到家目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd ~</div></pre></td></tr></table></figure></p><p>创建.vimrc文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vim .vimrc</div></pre></td></tr></table></figure></p><p>进入插入模式，复制下面代码，右击鼠标粘贴，不能是使用ctrl+V<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">filetype on</div><div class="line">syntax on</div><div class="line">set nu</div><div class="line">set cindent</div><div class="line">set ruler</div><div class="line">set tabstop=4</div><div class="line">set softtabstop=4</div><div class="line">set expandtab</div><div class="line">set shiftwidth=4</div><div class="line">set backspace=indent,eol,start</div><div class="line">set completeopt=preview,menu</div><div class="line">set cursorline</div><div class="line">set magic</div><div class="line">set autoindent</div><div class="line">set smartindent</div><div class="line">set showmatch</div><div class="line">set history=1000</div><div class="line">set nobackup</div><div class="line">set noswapfile</div><div class="line">set ignorecase</div><div class="line">set hlsearch</div><div class="line">set incsearch</div><div class="line">inoremap &apos; &apos;&apos;&lt;ESC&gt;i</div><div class="line">inoremap &quot; &quot;&quot;&lt;ESC&gt;i</div><div class="line">inoremap ( ()&lt;ESC&gt;i</div><div class="line">inoremap [ []&lt;ESC&gt;i</div><div class="line">inoremap &lt; &lt;&gt;&lt;ESC&gt;i</div><div class="line">inoremap &#123; &#123;&#125;&lt;ESC&gt;i</div><div class="line">set guifont=Bitstream_Vera_Sans_Mono:h10:cANSI</div></pre></td></tr></table></figure></p><p>好了现在使用编辑器就有那种花花绿绿的感觉了，这是我写的一个perl程序：<br><img src="http://oy0a9ohwa.bkt.clouddn.com/blog/171018/9AdKI49D5I.jpg" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做生信要写代码，写代码就需要编辑器，在linux系统下有一款编辑器不能被忽略，就是VIM，江湖人称编辑器之神。当然，在一堆程序员里面千万不要讨论语言的好坏，也不能突然冒一句perl是世界上最好的脚本语言，不能，千万不能，要不然死的很难看。&lt;/p&gt;
&lt;p&gt;所以讨论编辑器时也不能随便说哪个最好，人们常说vim是编辑器之神，继而又说他的对手emacs是神的编辑器。绕来绕去就是为了一个名分，所谓树争一身皮，编辑器争一口气。&lt;br&gt;VIM用好了以后的状态是这样子的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;写过程序的人都知道，编程的时候双手大部分时间都放在键盘上，或编码、或插入、或移动、或定位、或查找，这种连续操作的时间和频率远远大于阅读、翻页、设置字体、摆弄样式等文案工作，而二者往往产生很多停顿和间隙，而编程时的停顿是非常影响编程效率的，所以 Vim 的设计理念就是通过模式的转换、命令的组合和不计其数的插件，保证程序员在编程的过程中，双手尽可能保留在键盘中央的区域，并且，&lt;strong&gt;不需要鼠标&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="生物信息" scheme="http://guoshipeng.com/categories/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="编辑器" scheme="http://guoshipeng.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
      <category term="VIM" scheme="http://guoshipeng.com/tags/VIM/"/>
    
  </entry>
  
</feed>
