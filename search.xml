<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[apply家族的并行化并不完美！！！]]></title>
    <url>%2F2017%2F11%2F22%2F24-R-paralell%2F</url>
    <content type="text"><![CDATA[在运行完R代码版本的GSEA后，我就在想不能把GSEA并行化运行，最终发现，我并没有得到我想要的结果，百思不得其解，最终准备了一个小测试帮助我理解 12345678910111213i &lt;- c(1:100)i &lt;- matrix(i,rep(1,length(i))) #识别的是矩阵，dim(X) must have a positive lengtha &lt;- vector(length = Ng, mode = &quot;numeric&quot;)#写一个函数,计算输入的值的开放，并且存入向量mytest_fun &lt;- function(i)&#123; a[i] &lt;- sqrt(i)&#125;require(parallel)cl.cores &lt;- detectCores() #detectCores()检查当前电脑可用核数cl &lt;- makeCluster(28) #makeCluster(cl.cores)使用刚才检测的核并行运算#这是坑，parApply里面用到的函数以及变量都需要申明clusterExport(cl,c(&quot;sqrt&quot;,&quot;i&quot;,&quot;a&quot;))parApply(cl,i,2,mytest_fun) 最终有结果，但是没有存进a使用&lt;&lt;- 符号设定全局变量 123456789i &lt;- c(1:100)i &lt;- matrix(i,rep(1,length(i)))a &lt;&lt;- vector(length = Ng, mode = &quot;numeric&quot;)mytest_fun &lt;- function(i)&#123; a[i] &lt;&lt;- sqrt(i)&#125;clusterExport(cl,c(&quot;sqrt&quot;,&quot;i&quot;,&quot;a&quot;))parApply(cl,i,2,mytest_fun) 依然没有存进a中尝试其他两种方法，for循环12345a &lt;&lt;- vector(length =100, mode = &quot;numeric&quot;)mytest_fun &lt;- function(i)&#123; a[i] &lt;&lt;- sqrt(i)&#125;for (i in 1:100) mytest_fun(i) 能够写入a尝试再使用一下apply函数1234567i &lt;- c(1:100)i &lt;- matrix(i,rep(1,length(i)))a &lt;&lt;- vector(length =100, mode = &quot;numeric&quot;)mytest_fun &lt;- function(i)&#123; a[i] &lt;&lt;- sqrt(i)&#125;apply(i,2,mytest_fun) 也能够写入a 下面尝试函数如何返回多个对象，把不同的结果写入矩阵a和矩阵bparApply肯定是不行的for循环呢？毫无疑问是可以的！！只要设定全局变量即可！12345678i &lt;- c(1:100)a &lt;&lt;- vector(length = 100, mode = &quot;numeric&quot;)b &lt;&lt;- vector(length = 100, mode = &quot;numeric&quot;)mytest_fun &lt;- function(i)&#123; a[i] &lt;&lt;- sqrt(i) b[i] &lt;&lt;- log(i)&#125;for (i in 1:100) mytest_fun(i) apply呢？也是可以的！！！1234567891011i &lt;- c(1:100)i &lt;- matrix(i,rep(1,length(i)))a &lt;&lt;- vector(length = 100, mode = &quot;numeric&quot;)b &lt;&lt;- vector(length = 100, mode = &quot;numeric&quot;)clusterExport(cl,c(&quot;sqrt&quot;,&quot;i&quot;,&quot;a&quot;,&quot;b&quot;,&quot;log&quot;))mytest_fun &lt;- function(i)&#123; a[i] &lt;&lt;- sqrt(i) b[i] &lt;&lt;- log(i)&#125;apply(i,2,mytest_fun) 被&lt;&lt;-搞糊涂了，最终测试发现，只要在函数里面用这个符号就可以了 而parApply呢，无论如何返回不了多个对象，看来GSEA的并行化是泡汤了，难怪昨天使用GSEA并行化到了最后总是提示错误原来是他没有返回该返回的对象。 现在的问题是：parApply不能把结果写入全局变量a中，解决这个问题，就可以把几乎所有的循环并行化啦！！！暂时不能解决！！]]></content>
      <categories>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>GSEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言找最小公倍数]]></title>
    <url>%2F2017%2F11%2F20%2F23-LCM%2F</url>
    <content type="text"><![CDATA[2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20? 找出能被1到20整除的最小数，就是1到20的最小公倍数以直觉来结题，对于每一个数判断他是不是能够被1到20的数整除，如果是就保留下来 12345n=1while(TRUE)&#123; if (sum(((n)%%seq(1,20) == 0)) &gt;= 20) break n = n +1&#125; 本质上这个应该能解题，但是算了半天没反应我就只到出问题了花间一下，这个数首先肯定能被20整除12345n=1while(TRUE)&#123; if (sum(((20*n)%%seq(1,20) == 0)) &gt;= 20) break n = n +1&#125; 还是算不出来，那应该还要同时被19整除12345n=1while(TRUE)&#123; if (sum(((380*n)%%seq(1,20) == 0)) &gt;= 20) break n = n +1&#125; 最后算出了答案，380*n=232792560 我看到也可以用分解质数方法来做，但是没有兴趣。]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在R中使用refGenome阅读GTF格式的文件]]></title>
    <url>%2F2017%2F11%2F16%2F22-GTF-RefG%2F</url>
    <content type="text"><![CDATA[虽然我们已经找到在R语言中读取GTF文件的最好方法但是不妨碍我们学习新的方法实际上rtracklayer::import就是个另类，一般而言大家读入GTF文件后只有9行refGenome也是，但是他可以把第九行轻松地取出来12install.packages(&quot;refGenome&quot;)library(refGenome) create ensemblGenome object for storing Ensembl genomic annotation data1ens &lt;- ensemblGenome() read GTF file into ensemblGenome object1read.gtf(ens, &quot;Homo_sapiens.GRCh38.90.chr.gtf&quot;) read.gtf(ens, “Homo_sapiens.GRCh38.90.chr.gtf”)[read.gtf.refGenome] Reading file ‘Homo_sapiens.GRCh38.90.chr.gtf’.[GTF] 2612134 lines processed.[read.gtf.refGenome] Extracting genes table.[read.gtf.refGenome] Found 58,243 gene records.[read.gtf.refGenome] Finished. 看一下他属性 class(ens)[1] “ensemblGenome”attr(,”package”)[1] “refGenome” 本次的重点来了create table of genes1my_gene &lt;- getGenePositions(ens) class(my_gene)[1] “data.frame”dim(my_gene)[1] 58243 26 这26个是变量分别是： testmygene &lt;- my_gene[1:5,]View(testmygene)names(testmygene)[1] “id” “seqid”[3] “source” “start”[5] “end” “score”[7] “strand” “frame”[9] “ccds_id” “protein_version”[11] “protein_id” “exon_version”[13] “transcript_support_level” “tag”[15] “exon_number” “gene_id”[17] “transcript_name” “gene_version”[19] “gene_name” “gene_source”[21] “gene_biotype” “transcript_id”[23] “transcript_source” “exon_id”[25] “transcript_version” “transcript_biotype” 获取也是非常容易。其实这个功能完全是可以自己写个函数来搞定的，之前已经写过了。根据这个帖子结合dplyr，他还可以做很多事情Read GTF file into R同时这个文章的作者已经坚持写作7年，是个生物信息学的大神，收入书签！比如可以每个染色体上有哪些gene类型123my_gene %&gt;% group_by(seqid, gene_biotype) %&gt;% summarise(count = n()) -&gt; my_tallyggplot(my_tally, aes(x =seqid, y = log2(count))) + geom_bar(aes(fill = gene_biotype), stat = &apos;identity&apos;, position = &apos;dodge&apos;)]]></content>
      <categories>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>TCGA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在R语言中读取TCGA的json文件并且获取样本ID]]></title>
    <url>%2F2017%2F11%2F16%2F21-R-TCGA-json%2F</url>
    <content type="text"><![CDATA[TCGA的原始数据下载后，只有一串字母混合的代号，没有样本号，所有的信息都存在metadata中，但是他的形式是json现在我们来读取json,需要安装jsonlite包。1234metadata &lt;- jsonlite::fromJSON(&quot;metadata.cart.2017-11-15T09_56_59.722935.json&quot;)library(tidyverse)metadata_id &lt;- metadata %&gt;% select(c(file_name,associated_entities)) 最终读到1208个观测，15个变量，我需要的是file_name和样本名称，样本名称藏在了associated_entities 列表中里面包括了entity_id,case_id,entity_submitter_id,entity_type这四个项目，查看第一个了解一下 metadata$associated_entities[1][[1]] entity_id case_id1 52033f64-1e6f-4657-a4fb-7cfeffc61951 39de7761-e762-4811-b95c-8216b79ae06b entity_submitter_id entity_type1 TCGA-AN-A0XW-01A-11R-A109-07 aliquot 现在的想法是我把ilename和associated_entities中的entity_submitter_id提取出来，放入列表中，形成1208个小列表每个小列表中包含两个元素，即lename和entity_submitter_id12345name_id &lt;- list()for (i in 1:1208)&#123; name_id[[i]] &lt;- substr(metadata_id$file_name[i],1,nchar(metadata_id$file_name[i])-3) name_id[[i]][2] &lt;- metadata_id$associated_entities[i][[1]]$entity_submitter_id&#125; ##不是很方便尝试直接把list转化成datafram，感受一下do.call的另类用法1naid_df &lt;- as.data.frame(do.call(rbind, name_id)) 得到的naid_df是一个2列1208行的数据框，实际上一开始避开list也可以完成，只是我选择了list，正好使用一下do.call 现在把1208个小文件读入一个矩阵文件，并且给每一个文件加上filename和entity_submitter_id之前有个帖子介绍过在R语言中将多个同样的行列式文件合并起来但是当时不知道，TCGA的单个文件是没有列名的，导致无法合并，本次要复杂一点123456#读入所有解压的文件 1208个，参考[R语言中选取多个文件夹中的文件合并到新的文件夹](http://guoshipeng.com/2017/11/13/15-multiple-files-into-one-by-R/)nameList &lt;- list.files(&quot;data_unzip/&quot;)location &lt;- which(naid_df==nameList[1],arr.ind = TRUE) ##which函数有一个已知value返回坐标的功能TCGA_id &lt;- as.character(naid_df[location[1],2]) ##通过坐标，获取TCGA_idexpr_df&lt;- read.table(paste0(&quot;data_unzip/&quot;,nameList[1]),stringsAsFactors = F, header = F) #读入第一个文件，保存为data.framenames(expr_df) &lt;- c(&quot;gene_id&quot;,TCGA_id) #给刚才数据库命名 这边开始批量作业1234567for (i in 2:length(nameList))&#123; location &lt;- which(naid_df==nameList[i],arr.ind = TRUE) TCGA_id &lt;- as.character(naid_df[location[1],2]) dfnew &lt;- read.table(paste0(&quot;data_unzip/&quot;,nameList[i]),stringsAsFactors = F,header = F) names(dfnew) &lt;- c(&quot;gene_id&quot;,TCGA_id) expr_df &lt;- inner_join(expr_df,dfnew,by=&quot;gene_id&quot;)&#125; 晚上走的时候没运行完，早上来的时候已经完毕，限速环节应该是read.table，早上再来尝试运行一次总是说内存不够我想到之前阅读GTF时，fread的速度很快，就试了一下1234567891011121314library(data.table)nameList &lt;- list.files(&quot;data_unzip/&quot;)location &lt;- which(naid_df==nameList[1],arr.ind = TRUE)TCGA_id &lt;- as.character(naid_df[location[1],2])expr_df&lt;- fread(paste0(&quot;data_unzip/&quot;,nameList[1]))names(expr_df) &lt;- c(&quot;gene_id&quot;,TCGA_id)for (i in 2:length(nameList))&#123; location &lt;- which(naid_df==nameList[i],arr.ind = TRUE) TCGA_id &lt;- as.character(naid_df[location[1],2]) dfnew &lt;- fread(paste0(&quot;data_unzip/&quot;,nameList[i])) names(dfnew) &lt;- c(&quot;gene_id&quot;,TCGA_id) expr_df &lt;- inner_join(expr_df,dfnew,by=&quot;gene_id&quot;)&#125; 大概花了15分钟左右1save(expr_df,file = &quot;brca_expr_df.Rda&quot;) 如果下次使用1load(file = &quot;brca_expr_df.Rda&quot;) 更新：无意间看一个帖子说list的获取可以使用$符号，但是在储存的时候要有特定的格式，相当于把第一个变量当做名称，直接￥调用如果成功的话，之前汇总文件的过程就会简单一点,应该是这种格式的循环12345name_id &lt;- list()for (i in 1:1208)&#123; list_name &lt;- substr(metadata_id$file_name[i],1,nchar(metadata_id$file_name[i])-3) name_id$list_name &lt;- metadata_id$associated_entities[i][[1]]$entity_submitter_id&#125; 使用第一个文件试一下12list_name &lt;- substr(metadata_id$file_name[1],1,nchar(metadata_id$file_name[1])-3)name_id$list_name &lt;- metadata_id$associated_entities[1][[1]]$entity_submitter_id 测试 一下 name_id$list_name[1] “TCGA-AN-A0XW-01A-11R-A109-07” 不对,直接把list_name的表达式放进去又不识别，换成下面的表达式还是不行1name_id &lt;- list(substr(metadata_id$file_name[1],1,nchar(metadata_id$file_name[1])-3) = metadata_id$associated_entities[1][[1]]$entity_submitter_id) 看到$符号，我想到我可以把这些数据弄进数据框，只有两行，行名是filename,把TCGAid弄成一行 试一下第一个数据123name_id &lt;- data.frame()list_name &lt;- substr(metadata_id$file_name[1],1,nchar(metadata_id$file_name[1])-3)name_id$list_name &lt;- metadata_id$associated_entities[1][[1]]$entity_submitter_id 不能运行,换一种表达方式123name_id &lt;- data.frame()name_id[1,1] &lt;- metadata_id$associated_entities[1][[1]]$entity_submitter_idnames(name_id)[1] &lt;- substr(metadata_id$file_name[1],1,nchar(metadata_id$file_name[1])-3) 成功，批量运行12345name_id &lt;- data.frame()for (i in 1:1208)&#123; name_id[1,i] &lt;- metadata_id$associated_entities[i][[1]]$entity_submitter_id names(name_id)[i] &lt;- substr(metadata_id$file_name[i],1,nchar(metadata_id$file_name[i])-3)&#125; 运行成功，速度也很快，下面提取每个数据12nameList &lt;- list.files(&quot;data_unzip/&quot;)TCGA_id &lt;- name_id$nameList[1]#这一步失败，最后发现是字符串中有-号，暂时没能解决 总结：fread速度很快R语言的data.frame如果列名包含“-”，无法使用$获取元素，在list中也是一样的情况等以后看能不能解决这个问题吧]]></content>
      <categories>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>TCGA</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在R语言中读取GTF文件的最好方法]]></title>
    <url>%2F2017%2F11%2F16%2F20-GTF-in-R%2F</url>
    <content type="text"><![CDATA[下载的TCGA数据是没有注释的，需要从ensemble上面下载GTF文件，现在需要把GTF文件读入R 第一种方法rtracklayer::import12345source(&quot;https://bioconductor.org/biocLite.R&quot;)biocLite(&quot;rtracklayer&quot;)biocLite(&quot;SummarizedExperiment&quot;)gtf1 &lt;- rtracklayer::import(&apos;Homo_sapiens.GRCh38.90.chr.gtf&apos;)gtf_df &lt;- as.data.frame(gtf1) 最终读入27个变量，2612129个观测，测试一下显示的不错12test &lt;- gtf_df[1:5,]View(test) 取出我需要的gene_id,gene_biotype,gene_name，成为新的数据框1geneid_df &lt;- dplyr::select(gtf_df,c(gene_name,gene_id,gene_biotype)) 第二种方法read.table1gtf2 &lt;- read.table(&apos;Homo_sapiens.GRCh38.90.chr.gtf&apos;, header = FALSE, sep = &apos;\t&apos;) 最后发现，速度奇慢无比,取消参考了Y叔的帖子增加参数，读入成功，需要1分钟,读入9个变量根据GTF画基因的多个转录本结构12gtf2 &lt;- read.table(&apos;Homo_sapiens.GRCh38.90.chr.gtf&apos;, stringsAsFactors = F, header = FALSE, sep = &apos;\t&apos;,comment = &quot;#&quot;)test2 &lt;- gtf2[1:5,] 第三种方法readr包里面的read_table2速度很快，有进度条，读入了18个变量，但是最gene_biotype显示不对1234gtf3 &lt;- readr::read_table2(&quot;Homo_sapiens.GRCh38.90.chr.gtf&quot;,comment = &quot;#&quot;)gtf_df3 &lt;- as.data.frame(gtf3) #转成data.frametest3 &lt;- gtf_df3[1:5,]View(test3) 第四种方法read.table，fread读入数据跟read.table一样，1234library(data.table)genes &lt;- fread(&quot;Homo_sapiens.GRCh38.90.chr.gtf&quot;)test4&lt;- genes[1:5,]View(test4) 上一步用时12秒，速度极快,只是读入后没有名字，需要自己添加读入9个变量,跟read.table一样1setnames(genes, names(genes), c(&quot;chr&quot;,&quot;source&quot;,&quot;type&quot;,&quot;start&quot;,&quot;end&quot;,&quot;score&quot;,&quot;strand&quot;,&quot;phase&quot;,&quot;attributes&quot;) ) 可选步骤，type那一项有转录本和gene，选取gene，其他有很多转录本1genes &lt;- genes[type == &quot;gene&quot;] 我要的信息粗存在attributes中，构建函数提取12345678extract_attributes &lt;- function(gtf_attributes, att_of_interest)&#123; att &lt;- strsplit(gtf_attributes,&quot;; &quot;) att &lt;- gsub(&quot;\&quot;&quot;,&quot;&quot;,unlist(att)) if(!is.null(unlist(strsplit(att[grep(att_of_interest, att)], &quot; &quot;))))&#123; return( unlist(strsplit(att[grep(att_of_interest, att)], &quot; &quot;))[2]) &#125;else&#123; return(NA)&#125;&#125; 举例子解释,加入我们需要gene_id12gtf_attributes &lt;- genes[1,9]att &lt;- strsplit(gtf_attributes,&quot;; &quot;) 这一步提示non-character argument，后面我查询才知道, 对于第九列的第一行的的获取两种方式返回的格式不一样12genes[1,9] #data.framegenes$attributes[1] #character 而strsplit的对象是character,重来123gtf_attributes &lt;- genes$attributes[1]att &lt;- strsplit(gtf_attributes,&quot;; &quot;)att &lt;- gsub(&quot;\&quot;&quot;,&quot;&quot;,unlist(att)) grep获取位置，获取到内容后分隔,得到的第二个元素是我们需要的1unlist(strsplit(att[grep(&quot;gene_id&quot;, att)], &quot; &quot;))[2] 利用函数获得基因列表1genes$gene_id &lt;- unlist(lapply(genes$attributes, extract_attributes, &quot;gene_id&quot;)) 如果我们选择使用第一种方法rtracklayer::import，这些事情都是不需要做的！！！ #总结：rtracklayer::import最简单，fread最快，read.table可选，read_table没戏！]]></content>
      <categories>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>TCGA</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用R语言来找回文数]]></title>
    <url>%2F2017%2F11%2F15%2F19-find-palin%2F</url>
    <content type="text"><![CDATA[第4题 A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.Find the largest palindrome made from the product of two 3-digit numbers. 意思是找出两个三位数乘积的最大回文数。最朴素的思路：写一个能判断回文数的函数，把三位数的乘积全部求出，一个个判断是否是回文数，再求最大数。1.首先我们创建一个函数来判断回文数123456if.palin &lt;- function(x)&#123; a &lt;- as.character(x) b &lt;- unlist(strsplit(a,&quot;&quot;)) if (all(b==b[length(b):1])) return (TRUE) else return(FALSE)&#125; 2.穷尽所有的三位数乘三位数的乘积12345678910g &lt;- 0palin &lt;- c()for (i in 100:999)&#123; for (j in 100:999)&#123; if (if.palin(i*j)==TRUE)&#123; g &lt;- g +1 palin[g] &lt;- i*j &#125; &#125;&#125; 3.找出最大的回文数max(palin) 906609 4.如果想知道每个回文数是由哪两个数组成的怎么办？改写一下代码，每次把结果存入列表中12345678910g &lt;- 0palin &lt;- list()for (i in 100:999)&#123; for (j in 100:999)&#123; if (if.palin(i*j)==TRUE)&#123; g &lt;- g +1 palin[g] &lt;- list(c(i*j,i,j)) &#125; &#125;&#125; 获取列表中每个列表的第一个数，注意”[[“在这个时候代表的是函数，表示获取12all &lt;- sapply(palin,&quot;[[&quot;,1)max(all) 得到906609，根据这个数值获取位置 which(all ==906609)[1] 2367 2468 有两个位置，这个情况是由之前的循环导致的，应该是一样的结果，只是顺序对调。 palin[2367][[1]][1] 906609 913 993 最终最大的回文数是906609，由913乘以993得到note：1.本次练习开始写函数，参考资料为Advanced R 第二版，但是这函数只能起到判断的作用。2.rev()函数可以实现向量倒序，代替b[length(b):1])) = rev(b)3.切开字符串使用strsplit,如果在拼回去需要用paste paste(c(“B”,”S”),collapse = “”)[1] “BS”]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[万万使不得！-R语言中的循环套循环]]></title>
    <url>%2F2017%2F11%2F15%2F18-find-prime%2F</url>
    <content type="text"><![CDATA[这是第3题 The prime factors of 13195 are 5, 7, 13 and 29.What is the largest prime factor of the number 600851475143 ? 就是找出600851475143中最大的质数。我的思路是，找出小于600851475143的质数，得到质数表，然后用600851475143除以这些质数再判断首先找出小于600851475143的质数思路是，如果一个数不能被其他除了自己和1的数整除，那么他就是质数，很明显我是按照定义来的123456789101112k &lt;- 2x &lt;-c(2,3)for (j in 5:600851475143)&#123; a &lt;-c() for (i in 2:(j-1))&#123; a[i-1] = sum( j%%i == 0) &#125; if (sum(a)==0)&#123; k = k + 1 x[k] = j &#125;&#125; 运行后提示： Error: cannot allocate vector of size 4476.7 Gb 我想了一下，不需要数到600851475143，到他的平方根即可123456789101112k &lt;- 2x &lt;-c(2,3)for (j in 5:sqrt(600851475143))&#123; a &lt;-c() for (i in 2:(j-1))&#123; a[i-1] = sum( j%%i == 0) &#125; if (sum(a)==0)&#123; k = k + 1 x[k] = j &#125;&#125; 这一次应该可以，但是运行时间太久，我等了半天都不行，我先测试一下代码是否正确123456789101112k &lt;- 2x &lt;-c(2,3)for (j in 5:10000)&#123; a &lt;-c() for (i in 2:(j-1))&#123; a[i-1] = sum( j%%i == 0) &#125; if (sum(a)==0)&#123; k = k + 1 x[k] = j &#125;&#125; 运行大概需要20s，k是1229,说明找到了1229个质数，最大的是max(x),9973那么用600851475143除以x[k],先看看这一群中能除尽的最大数12y &lt;- 600851475143x[which(y %% x==0)] 输出结果是 x[which(y %% x==0)][1] 71 839 1471 6857 最大是6857，恰巧这四个数的乘积就是600851475143，说明蒙对了。我在想有没有什么通用的方法呢？在网上检索了一下质数的查找方法找质数算法之埃拉托色尼筛选法-Sieve of Eratosthenes算法在R语言中使用这个方法获取质数1234567891011x &lt;- 600851475143num &lt;- 2:sqrt(x)i &lt;- 0wt &lt;- c(2) #用于储存质数repeat&#123; i &lt;- i +1 num &lt;- num[which(num %% num[1] !=0)] #每次把第一个数以及他的倍数去除 wt[i+1] &lt;- num[1] #把第一个数传入向量中 if (length(num) == 0) break #repeat需要设定终止条件&#125;wt &lt;- wt[-length(wt)] #去掉最后一个NA 最终发现这个方法是可行的12y &lt;- 600851475143wt[which(y %% wt==0)] wt[which(y %% wt==0)][1] 71 839 1471 6857 这时候确定无疑就是6857，并且很高兴解决了这么多问题，然后就去参考一下别人博客的答案 这个先写了一个能判断质数的函数，其中all用的很传神，我在之前不知道有这个函数，就用了迂回的方法代替12345678findprime &lt;- function(x) &#123; if (x %in% c(2,3,5,7)) return(TRUE) if (x%%2 == 0 | x==1) return(FALSE) xsqrt &lt;- round(sqrt(x)) xseq &lt;- seq(from=3,to=xsqrt,by=2) if (all(x %% xseq !=0)) return(TRUE) else return(FALSE)&#125; 测试一下效果12x = 1:700000x[sapply(x,findprime)] 发现速度特别快,下面找出最大的质数123456789n &lt;- 600851475143for (i in seq(from=3, to=round(sqrt(n)), by=2)) &#123; if (findprime(i) &amp; n %% i == 0) &#123; n &lt;- n / i prime.factor &lt;- i if (i &gt;= n) break &#125;&#125;print(prime.factor) 得到的答案是6857，而且速度很快，几乎是秒出，太惊讶了！！！修改一下代码，得到所有的质数123456789101112n &lt;- 600851475143j &lt;- 0factor &lt;- c()for (i in seq(from=3, to=round(sqrt(n)), by=2)) &#123; if (findprime(i) &amp; n %% i == 0) &#123; n &lt;- n / i j &lt;- j + 1 factor[j] &lt;- i if (i &gt;= n) break &#125;&#125;print(factor) print(factor)[1] 71 839 1471 6857 总结：1.使用字母时为什么常用i和j呢？因为他们大小写不容易混淆，我今天使用的是k，大小写分不清，会出现object “k” not found 的提示2.要学会写函数3.尽量不要循环里面套循环，速度会很慢4.all()和any()的用法5.学习Adcanced R里面的函数章节函数Functions泛函数Functionals]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言中的循环]]></title>
    <url>%2F2017%2F11%2F14%2F17-loops-in-r%2F</url>
    <content type="text"><![CDATA[Project Euler01Problem 2, Even Fibonacci numbers Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:1, 2, 3, 5, 8, 13, 21, 34, 55, 89, …By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms. 400万以内的偶数斐波那契数列求和 12345678910x[1] &lt;- 1x[2] &lt;- 2for (i in 3:1000)&#123; x[i]=x[i-1] +f[i-2] if (x[i] &gt; 4000000)&#123; break &#125;&#125;x &lt;- x[-i]sum(x[x %% 2 == 0]) 结果4613732但是我并不知道x[i] &gt; 4000000时i是多少，看了别人的答案可以使用while解决这个问题12345678i &lt;- 2x &lt;- 1:2while (x[i] &lt; 4e6) &#123; x[i+1] &lt;- x[i-1] + x[i] i &lt;- i + 1&#125;x &lt;- x[-i]sum(x[x %% 2 == 0]) 看了一下r-bloggers上别人的答案发现还可以用repeat这个命令1234567891011121314fibonacci &lt;- numeric()fibonacci[1] &lt;- 1fibonacci[2] &lt;- 2i &lt;- 3repeat &#123; fibonacci[i] &lt;- fibonacci[i-1] + fibonacci[i-2] if (fibonacci[i] &gt; 4e6) break i &lt;- i + 1&#125;# calculate the sumfibonacci &lt;- fibonacci[-length(fibonacci)] # remove the last termflag &lt;- fibonacci %% 2 == 0 # find the indexes of even numbersresult &lt;- sum(fibonacci[flag])cat(&quot;The result is:&quot;, result, &quot;\n&quot;) 现在有两个问题1.repeat和while有什么区别？2.R语言中的循环有多少种？for,while,repeat,向量化操作,apply,自己写的函数也算。这里有一份来自Datacamp的Tutorials十分值得阅读，价值250美元，很长很全面，但是很好懂A Tutorial on Loops in R - Usage and Alternatives]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言究竟能不能优雅？]]></title>
    <url>%2F2017%2F11%2F13%2F16-project-eluer-01-3-and-5%2F</url>
    <content type="text"><![CDATA[Project Euler01今天我无意间进入肖凯的博客，看到这样一篇文章R语言编程入门之二：对象和类讲得挺好，但是我还是不能理解面向编程这一套逻辑，最近会解决这个问题 然后在逛博客的时候发现他写的笨办法学R编程里面举的例子就是Project Euler 上的第一题,Project Euler是一系列由易到难的计算机编程挑战，它提供了一个平台来激发我们解决问题的灵感和思路。 找到1000以下，所有能被3或5整除的数，将它们相加 原文如下： If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.Find the sum of all the multiples of 3 or 5 below 1000. 我一看挺简单，就尝试做了一下，中途好几次想看答案，忍住没看123456789n =0a =c()for (x in 1:999) &#123; if (x %% 3==0 | x %% 5 == 0)&#123; n = n +1 a[n] = x &#125;&#125;sum(a) 最终结果是233168然后我看了一下肖凯的解决方案：12x &lt;- 1:999sum(x[x %% 3 == 0 | x %% 5 == 0 ]) 大惊失色，我的思维还停留在刚学Python那会的水平，差距不是点吧点我在留言下面看到了ygc，应该是Y叔的留言，那是在2013年10月26日的下午12x &lt;- 1:999sum(ifelse(x%%3 &amp; x%%5, 0,x)) 随即他又给出了一行代码版本，完全的函数式编程范！1sum(sapply(1:999, function(x) ifelse(x%%3 &amp; x%%5, 0, x))) 前方的路真长接着我又看到了一个奇特版本,思路也很简单，但是在R语言里面我想不到1sum(seq(3, 999, 3)) + sum(seq(5, 999, 5)) - sum(seq(15, 999, 15)) 我看了一下Project Euler 上面现在有600多题，而且还在不断增长是个学习的好机会，但是没有评判结果不行，我又在R-blogger上面发现很多答案https://www.r-bloggers.com/tag/project-euler/实在太开心了。]]></content>
      <categories>
        <category>Project Euler</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言中选取多个文件夹中的文件合并到新的文件夹]]></title>
    <url>%2F2017%2F11%2F13%2F15-multiple-files-into-one-by-R%2F</url>
    <content type="text"><![CDATA[之前的帖子解决了在R语言中将多个同样的行列式文件合并起来的问题今天在处理TCGA数据时发现，数据下载后是放在单独的文件夹中的，几百个文件夹里面都有一个我们需要的文件，需要把他们转移到新的文件中去，我看到perl语言的处理方式，应该R语言也可以完成我这么做的原因就是，在使用R语言处理数据时有个观点，我从两个人那边听到的，但是我现在还不能凝练： jimmy说，不要把数据导出为excel，然后下次又呆呆地导入，直接储存为”*.Rda”,要用的时候load即可，不需要来回读写 Y叔说，只要你还没有把图导出来打印，数据就是图，图就是数据，一切转换都有可能 对我而言，最直接的原因就是，在R语言中处理数据，突然间中断使用其他语言的脚本来处理某个过程，这个状态很诡异，再怎么说R语言也是语言，和其他语言比对perl比，处理数据顶多只是复杂和简单的关系，不应该是不能完成才对！ ##建立测试数据，创建10个文件夹，同时在每个文件夹中创立10个新的文件 ##经过试验我发现，dir不能批量生成，需要使用for循环，但是file可以批量1234for (i in 1:10) &#123; dir.create(paste0(&quot;tmp_&quot;,i)) #创建10个文件夹 file.create(paste0(&quot;tmp_&quot;,i,&quot;/counts&quot;,i,&quot;.htq&quot;,seq(1:10))) #同时在每个文件夹中创立10个新的文件&#125; 查看数据,忽略TCGAbiolinks dir()[1] “111.R” “112.R” “TCGAbiolinks.Rproj”[4] “TCGAbiolinks_2.5.7.zip” “tmp_1” “tmp_10”[7] “tmp_2” “tmp_3” “tmp_4”[10] “tmp_5” “tmp_6” “tmp_7”[13] “tmp_8” 查看tmp_1文件夹中的内容 dir(“tmp_1”)[1] “counts1.htq1” “counts1.htq10” “counts1.htq2” “counts1.htq3”[5] “counts1.htq4” “counts1.htq5” “counts1.htq6” “counts1.htq7”[9] “counts1.htq8” “counts1.htq9” ##任务：取每个文件夹中的第二个文件，就是名称以htq2结尾的文件 ##并且把他们放到一个新的文件夹中去12345dir.create(&quot;tmp_all&quot;) #创建新的文件夹for (dirname in dir()[5:14])&#123; file &lt;- list.files(dirname,pattern = &quot;*.htq2&quot;) #找到对应文件夹中的内容，pattern可以是正则表达式 file.copy(paste0(dirname,&quot;/&quot;,file),&quot;tmp_all&quot;) #复制内容到新的文件夹&#125; 其中dir()[5:14] 只是因为我自己的文件夹下有很多别的东西，这里是选取我想要的文件夹 dir()[5:14][1] “tmp_1” “tmp_10” “tmp_2” “tmp_3” “tmp_4” “tmp_5” “tmp_6” “tmp_7”[9] “tmp_8” “tmp_9” 我们看一下tmp_all是否已经有了文件 dir(“tmp_all”)[1] “counts1.htq2” “counts10.htq2” “counts2.htq2” “counts3.htq2”[5] “counts4.htq2” “counts5.htq2” “counts6.htq2” “counts7.htq2”[9] “counts8.htq2” “counts9.htq2” 最终我发现，R语言处理起来也很简单！有了一个隐蔽的博客真是好，随心所欲地记录。]]></content>
      <categories>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>TCGA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在R语言中将多个同样的行列式文件合并起来]]></title>
    <url>%2F2017%2F11%2F10%2F14-R-for-binding-colums%2F</url>
    <content type="text"><![CDATA[今天在论坛学习TCGA-RNA seq的处理，看见这样一道题，生信编程直播第四题：多个同样的行列式文件合并起来想起当时R语言不熟练，根本不敢去看，今天尝试解决一下，原来如此简单。这也是一个收集教案的过程，以后在课上的例子会生动需对，这一道题可以用来讲解for循环。下载数据，解压到GSE48213_RAW，list.files用于列出文件夹下所包含的文件名inner_join和merge函数一样123456789library(dplyr)nameList &lt;- list.files(&quot;GSE48213_RAW/&quot;)matrix &lt;- read.table(paste0(&quot;GSE48213_RAW/&quot;,nameList[1]),header = T)for (i in 2:length(nameList))&#123; matrix &lt;- inner_join(matrix, read.table(paste0(&quot;GSE48213_RAW/&quot;,nameList[i]),header = T), by=&quot;EnsEMBL_Gene_ID&quot;)&#125;save(matrix,file = &quot;56_cell_expression.Rda&quot;)]]></content>
      <categories>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Rstudio server中R的多版本切换]]></title>
    <url>%2F2017%2F11%2F10%2F13-two-versions-of-R%2F</url>
    <content type="text"><![CDATA[本次记录是为了自己查看：在前一篇文章中，我自己编译了一个R 安装R version 3.4.2 Patched下载地址:https://stat.ethz.ch/R/daily/123456tar -xf R-patched_2017-11-05.tar.gzsudo apt-get build-dep r-base-dev./configure --enable-R-shlib=yesmakemake checksudo make install 在terminal中使用1which R /usr/local/bin/R 那么Rstudio会默认使用这个R 今天又安装了一个新的R，不是编译的1sudo apt-get install r-base 在终端中1/usr/bin/R 可以打开这个新的版本如果想要能够在Rstudio server中切换1sudo vim /etc/rstudio/rserver.conf 在里面写入 rsession-which-r=/usr/bin/R也可以是rsession-which-r=/usr/lib/R 这时候重启Rstudio server ，新开一个session就可以看到版本已经改过来了如果要回到之前的版本在/etc/rstudio/rserver.conf修改即可 rsession-which-r=/usr/local/bin/R也可以是rsession-which-r=/usr/local/lib/R 这个是修改Rstuido中默认的R版本，同时我们可以自定义每个用户的R默认版本，方法如下http://docs.rstudio.com/ide/server-pro/r-versions.html#r-versions内容真实丰富，暂时没搞懂，不过这个文档不错。 本文参考文章：https://support.rstudio.com/hc/en-us/articles/200486138-Using-Different-Versions-of-R]]></content>
      <categories>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04-R3.4.2下安装clusterProfiler出现错误的解决过程]]></title>
    <url>%2F2017%2F11%2F06%2F12-ubuntu-and-R%2F</url>
    <content type="text"><![CDATA[最近在学习聚类分析，看了Y叔的一系列帖子，觉得clusterProfiler就是传说中一包走天下的神包在windows和mac都安装成功，这是背景。在Ubuntu16.04，R3.4.2(2017-09-28)下运行一下命令，发生错误12source(&quot;https://bioconductor.org/biocLite.R&quot;)biocLite(&apos;clusterProfiler&apos;) ** preparing package for lazy loadingCreating a new generic function for ‘append’ in package ‘BiocGenerics’Creating a new generic function for ‘as.data.frame’ in package ‘BiocGenerics’Creating a new generic function for ‘cbind’ in package ‘BiocGenerics’Error : identical(as.call(parse(text = old_code)[[1L]]), body[[7L]][[3L]]) is not TRUEError in apply_hotfix73465(getGeneric(“cbind”)) : hotfix failed for generic function cbind()Error : unable to load R code in package ‘BiocGenerics’ERROR: lazy loading failed for package ‘BiocGenerics’ removing ‘/home/shipeng/opt/biosoft/R/bioconductor/BiocGenerics’ERROR: dependency ‘BiocGenerics’ is not available for package ‘S4Vectors’ removing ‘/home/shipeng/opt/biosoft/R/bioconductor/S4Vectors’ERROR: dependencies ‘BiocGenerics’, ‘S4Vectors’ are not available for package ‘IRanges’ removing ‘/home/shipeng/opt/biosoft/R/bioconductor/IRanges’ERROR: dependencies ‘BiocGenerics’, ‘IRanges’, ‘S4Vectors’ are not available for package ‘AnnotationDbi’ removing ‘/home/shipeng/opt/biosoft/R/bioconductor/AnnotationDbi’ERROR: dependency ‘AnnotationDbi’ is not available for package ‘DO.db’ removing ‘/home/shipeng/opt/biosoft/R/bioconductor/DO.db’ERROR: dependency ‘AnnotationDbi’ is not available for package ‘GO.db’ removing ‘/home/shipeng/opt/biosoft/R/bioconductor/GO.db’ERROR: dependencies ‘AnnotationDbi’, ‘GO.db’ are not available for package ‘GOSemSim’ removing ‘/home/shipeng/opt/biosoft/R/bioconductor/GOSemSim’ERROR: dependencies ‘AnnotationDbi’, ‘DO.db’, ‘GOSemSim’, ‘igraph’, ‘S4Vectors’ are not available for package ‘DOSE’ removing ‘/home/shipeng/opt/biosoft/R/bioconductor/DOSE’ERROR: dependencies ‘DOSE’, ‘AnnotationDbi’, ‘GO.db’, ‘GOSemSim’ are not available for package ‘clusterProfiler’ removing ‘/home/shipeng/opt/biosoft/R/bioconductor/clusterProfiler’ 如果仅仅运行这个代码12source(&quot;https://bioconductor.org/biocLite.R&quot;)biocLite() Error : unable to load R code in package ‘BiocGenerics’ERROR: lazy loading failed for package ‘BiocGenerics’ removing ‘/home/shipeng/opt/biosoft/R/bioconductor/BiocGenerics’ERROR: dependency ‘BiocGenerics’ is not available for package ‘S4Vectors’ removing ‘/home/shipeng/opt/biosoft/R/bioconductor/S4Vectors’ERROR: dependencies ‘BiocGenerics’, ‘S4Vectors’ are not available for package ‘IRanges’ removing ‘/home/shipeng/opt/biosoft/R/bioconductor/IRanges’ERROR: dependencies ‘BiocGenerics’, ‘IRanges’, ‘S4Vectors’ are not available for package ‘AnnotationDbi’ removing ‘/home/shipeng/opt/biosoft/R/bioconductor/AnnotationDbi’ 追根溯源就是第一个‘BiocGenerics’没有安装成功那我就来单独安装12source(&quot;https://bioconductor.org/biocLite.R&quot;)biocLite(&apos;BiocGenerics&apos;) 报错信息如下： ** preparing package for lazy loadingCreating a new generic function for ‘append’ in package ‘BiocGenerics’Creating a new generic function for ‘as.data.frame’ in package ‘BiocGenerics’Creating a new generic function for ‘cbind’ in package ‘BiocGenerics’Error : identical(as.call(parse(text = old_code)[[1L]]), body[[7L]][[3L]]) is not TRUEError in apply_hotfix73465(getGeneric(“cbind”)) : hotfix failed for generic function cbind()Error : unable to load R code in package ‘BiocGenerics’ERROR: lazy loading failed for package ‘BiocGenerics’ removing ‘/home/shipeng/opt/biosoft/R/bioconductor/BiocGenerics’ 实际上如果biocLite(‘BiocGenerics’)装不上，那么内部缺少的依赖包不能通过biocLite(‘xxx’)这种形式安装在R语言中执行1sessionInfo() R version 3.4.2 (2017-09-28)Platform: x86_64-pc-linux-gnu (64-bit)Running under: Ubuntu 16.04.3 LTSMatrix products: defaultBLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.7.1LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.7.1locale:[1] LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C LC_TIME=en_US.UTF-8[4] LC_COLLATE=en_US.UTF-8 LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8[7] LC_PAPER=en_US.UTF-8 LC_NAME=C LC_ADDRESS=C[10] LC_TELEPHONE=C LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=Cattached base packages:[1] parallel stats graphics grDevices utils datasets methods baseother attached packages:[1] BiocInstaller_1.28.0 ggpubr_0.1.5 magrittr_1.5 ggplot2_2.2.1[5] survival_2.41-3 dplyr_0.7.4 bindrcpp_0.2loaded via a namespace (and not attached):[1] Rcpp_0.12.13 compiler_3.4.2 plyr_1.8.4 bindr_0.1 tools_3.4.2[6] tibble_1.3.4 gtable_0.2.0 nlme_3.1-131 lattice_0.20-35 pkgconfig_2.0.1[11] rlang_0.1.2 Matrix_1.2-11 psych_1.7.8 yaml_2.1.14 knitr_1.17[16] grid_3.4.2 glue_1.2.0 R6_2.2.2 foreign_0.8-69 scales_0.5.0[21] splines_3.4.2 assertthat_0.2.0 mnormt_1.5-5 colorspace_1.3-2 lazyeval_0.2.1[26] munsell_0.4.3 也看不出什么名堂google发现有人在bioconduct社区提问了相同的问题：https://support.bioconductor.org/p/101833/ 给出来三种解决方法：第一，说尝试打开一个新的R session可以解决问题1R --vanilla 照做后发现不能解决问题有人在评论里面说 Glad that installing R 3.4.2 Patched solved the problem 但是这个版本我下载configure会报错(实际上是我不会编译R)就放弃了 我还看到有人说， sudo apt-get install r-bioc-biocgenerics 这个命令可以解决问题照做后显示我安装成功 (Reading database … 185900 files and directories currently installed.)Preparing to unpack …/r-bioc-biocgenerics_0.22.1-1ubuntu1_all.deb …Unpacking r-bioc-biocgenerics (0.22.1-1ubuntu1) …Setting up r-bioc-biocgenerics (0.22.1-1ubuntu1) … 这时候我感到很高兴再来安装Y叔的包12source(&quot;https://bioconductor.org/biocLite.R&quot;)biocLite(&apos;clusterProfiler&apos;) 又报错： installing to /home/shipeng/opt/biosoft/R/bioconductor/S4Vectors/libs R inst** preparing package for lazy loadingError : package ‘BiocGenerics’ 0.22.1 was found, but &gt;= 0.23.3 is required by ‘S4Vectors’ERROR: lazy loading failed for package ‘S4Vectors’ removing ‘/home/shipeng/opt/biosoft/R/bioconductor/S4Vectors’ 提示我安装的版本不够高好的，现在我的问题可能就是安装版本高一点的R包，但是默认的biocLIte()是不行的我查到可以通过github来安装,并且有两种方式第一种方式需要知道包在github的名字，不是很方便123install.packages(&quot;devtools&quot;)library(devtools)install_github(&quot;xxx&quot;) 第二种方式方便一点1install.packages(&quot;githubinstall&quot;) 报错 ERROR: configuration failed for package ‘curl’ removing ‘/home/shipeng/opt/biosoft/R/bioconductor/curl’Warning in install.packages :installation of package ‘curl’ had non-zero exit statusERROR: dependency ‘curl’ is not available for package ‘githubinstall’ removing ‘/home/shipeng/opt/biosoft/R/bioconductor/githubinstall’ 提示我缺少curl,那我就装一个1install.packages(&quot;curl&quot;) 报错 ERROR: configuration failed for package ‘curl’ removing ‘/home/shipeng/opt/biosoft/R/bioconductor/curl’Warning in install.packages :installation of package ‘curl’ had non-zero exit statusThe downloaded source packages are in ‘/tmp/Rtmp0YZPFO/downloaded_packages’ 还是没能解决,所以安装包的时候出现的问题，不能用R本身来解决！需要走其他的途径网上说这个可以解决问题1sudo apt-get install libcurl4-openssl-dev 安装完事后我又试了一下1install.packages(&quot;githubinstall&quot;) 安装成功，那我就安装BiocGenerics试试12library(githubinstall)githubinstall(&apos;BiocGenerics&apos;) Select a number or, hit 0 to cancel.1: Bioconductor/BiocGenerics S4 generic functions for Bioconductor2: lshep/BiocGenerics alpha testing github3: nturaga/BiocGenerics test4: schifferl/BiocGenerics 试了第1个，第二个都失败选择第三个后 help* installing help indices building package indices testing if installed package can be loaded DONE (BiocGenerics) 成功!!!，我有开始安装Y叔的包12source(&quot;https://bioconductor.org/biocLite.R&quot;)biocLite(&apos;clusterProfiler&apos;) installing to /home/shipeng/opt/biosoft/R/bioconductor/S4Vectors/libs R inst** preparing package for lazy loadingError : package ‘BiocGenerics’ 0.23.0 was found, but &gt;= 0.23.3 is required by ‘S4Vectors’ 版本还是不够，这回真的没辙了而使用biocLite()安装的报错信息我看不懂 Error : identical(as.call(parse(text = old_code)[[1L]]), body[[7L]][[3L]]) is not TRUEError in apply_hotfix73465(getGeneric(“cbind”)) : hotfix failed for generic function cbind() 问了Y叔，给了我一个帖子无痛更新R包1rvcheck::update_all() 最后发现没有用 所以我来尝试一下帖子里说的安装R version 3.4.2 Patched下载地址:https://stat.ethz.ch/R/daily/ 1./configure 报错 error: –with-readline=yes (default) and headers/libs are not available 上网查找https://stackoverflow.com/questions/20752307/error-in-install-previous-versions-of-r-on-ubuntu这里提供解决方案1sudo apt-get install xorg-dev https://cran.r-project.org/doc/manuals/R-admin.html#Essential-programs-and-libraries这个文档给出详细的解释 Unless you do not want to view graphs on-screen (or use macOS) you need ‘X11’ installed, including its headers and client libraries. For recent Fedora/RedHat distributions it means (at least) RPMs ‘libX11’, ‘libX11-devel’, ‘libXt’ and ‘libXt-devel’. On Debian/Ubuntu we recommend the meta-package ‘xorg-dev’. If you really do not want these you will need to explicitly configure R without X11, using –with-x=no. 运行后提示： R is now configured for x86_64-pc-linux-gnuconfigure: WARNING: you cannot build info or HTML versions of the R manualsconfigure: WARNING: you cannot build PDF versions of the R manualsconfigure: WARNING: you cannot build PDF versions of vignettes and help pages 启动R1sudo R R version 3.4.2 Patched (2017-11-05 r73673) – “Short Summer”Copyright (C) 2017 The R Foundation for Statistical ComputingPlatform: x86_64-pc-linux-gnu (64-bit) 好了应该是按照成功了尝试安装BiocGenerics12source(&quot;https://bioconductor.org/biocLite.R&quot;)biocLite(&apos;BiocGenerics&apos;) 最终安装成功 help* installing help indices building package indices testing if installed package can be loaded DONE (BiocGenerics) 可是我现在启动不了Rstudio ERROR Unable to find libR.so in expected locations within R Home direc 把libR.so找到，复制指定目录下，最后发现rstudio成功，但是在rstudio所有R还是以前的版本更改各种设置都不行，系统里面有两个R,删除掉其中一个重新安装r123456tar -xf R-patched_2017-11-05.tar.gzsudo apt-get build-dep r-base-dev./configure --enable-R-shlib=yesmakemake checksudo make install 没有任何报错！！！https://bookdown.org/yihui/r-ninja/setup.html#r谢益辉说的这个无敌命令一次性解决依赖问题1sudo apt-get build-dep r-base-dev 在终端启动R123source(&quot;https://bioconductor.org/biocLite.R&quot;)options(BioC_mirror=&quot;http://mirrors.ustc.edu.cn/bioc/&quot;)biocLite(&apos;clusterProfiler&apos;) 报错说没有装上igraph1apt-get install -y r-cran-igraph 报错12E: Could not open lock file /var/lib/dpkg/lock - open (13: Permission denied)E: Unable to lock the administration directory (/var/lib/dpkg/), are you root? 加上root权限：1sudo apt-get install -y r-cran-igraph 安装完了之后，在r里面无法library1ibrary(igragh) 使用1install.packages(&quot;igraph&quot;) 安装成功再来安装Y叔的包DOSE包安装失败安装DOSE包1devtools::install_github(&quot;GuangchuangYu/DOSE&quot;) 报错 Error in dyn.load(file, DLLpath = DLLpath, …) : unable to load shared object ‘/home/shipeng/opt/biosoft/R/bioconductor/stringi/libs/stringi.so’: libicui18n.so.57: cannot open shared object file: No such file or directory 安装1install.packages(&quot;stringi&quot;) 安装1biocLite(&apos;DOSE&apos;) 成功1biocLite(&apos;clusterProfiler&apos;) 成功！！！测试数据：12345biocLite(&quot;ggridges&quot;)require(clusterProfiler)data(geneList)x &lt;- gseKEGG(geneList)ridgeplot(x,showCategory = 60) 出图如下：这图出的不容易！！！！！]]></content>
      <categories>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>R</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[perl语言中文件句柄和参数设置的理解]]></title>
    <url>%2F2017%2F10%2F18%2F11-perl-handle%2F</url>
    <content type="text"><![CDATA[这是过年期间的学习笔记，这段时间被标书虐的死去活来，休息的时候编辑了，这样提交完标书就可以学习RNA-seq了。文件句柄 这个概念光看字面完全不知所措，但是当我处理了一些数据时慢慢就能够理解。向别人解释一个概念最好的方法是类比，小时候听老师说地球就像鸡蛋，一下就理解了。目前我找到的能解释文件句柄的好类比就是：摆渡船，没错，文件句柄就像摆渡船，他每次去对岸接一定人数的客人到这边来。而文件句柄的作用就是按照你的要求每次从文件中取出一部分数据供你处理。下面举例子来理解：我们要把几个序列格式化输出，要求每行60个字符。原始文件如下：每一个&gt;开头的是一个序列文件，写到这里我突然间就有点伤感，这些东西我是知道的，为什么我还要写下来，给谁看呢，那么多的人在学python，只有少数人在用perl，Larry wall知道了是不是要很生气。我编辑的不是文案，我只是在拼凑破碎的心。你可以看到每一个序列在每行的长度不一样。总共5个序列，想要让他们按照每一行60个字母呈现出来我打开VIM，写下一下的代码，然后注释了一下。运行程序后屏幕上显示：说明成功了，那么这时候出现两个问题： 如果我处理其他文本这么办？ 如果我想每行50个字母，40个字母怎么办？为了解决这个问题，需要引入参数这个概念：在原有脚本的基础上，修改两个地方这时候假如要实现50字母每行，那么就在终端输入：屏幕上显示：这样我们就算成功了，此时我注意到我在一开始创建测试文件need_cahnge.fa时把scafald写错了，正确的单词应该是Scaffold，所以我准备使用pl程序把他修改好，并且输出到一个新的文件changed.fa终端输入下列命令：这个命令由四个部分组成： 第一个部分是perl，这是所有执行perl程序都需要的 第二个部分为perl程序的名称 第三个部分为第一个参数，就是输入的文件名 第四个部分为第二个参数，就是输出的文件名最后得到的结果如下：看吧，名称已经换掉了。我想我应该理解perl语言的文件句柄了。实际上当我再次会看这个笔记的时候，我发现我陷入了怪圈，这个例子纯粹是为了将参数的作用要替换一个文本里面的单词，为什么我不直接使用全局替换呢，整这么麻烦还沾沾自喜。]]></content>
      <categories>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>Perl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[perl语言中的字符串处理及排序]]></title>
    <url>%2F2017%2F10%2F18%2F10-perl-string%2F</url>
    <content type="text"><![CDATA[生物信息中的数据是以字符串形式呈现的，而perl语言90%的常用功能都在处理字符串上。所以我用了一些时间来学习这些处理字符串的手段。比较重要的是index，substr，sort。 首先是姐妹花index和rindex index 从左边开始给出匹配字符的首字符位置 rindex 从右边开始给出匹配字符的首字符位置 注意:字符串的第一个位置为0因为放假没办法用到服务器，所以perl语言的学习全是在mac电脑的终端完成的，其实和linux的终端完全一样。下面我们设计了一个字符串，他有两个ATG，第一个ATG的A的位置为0，第二个ATG的A的位置为15，我们试一下:index和rindex有三个参数，第一个为要匹配的序列，第二个为目标字符串，第三个为开始匹配的位置（这个参数可选），当index匹配不到字符串时返回-1，例子中，第四个我们让他从第20个字符开始查找ATG，实际上没有20之后没有ATG了，所以返回值为-1 既然可以查找字符串的位置，那么就自然想到截取一段序列，这时候要用到substr函数（其实这个概念我是从excel中知道的）还是刚才那个序列，这次的目的是：提取出第二个ATG开始到最后一个TAA结束的序列：思路就是知道要截取的序列，知道开始位置，知道截取长度就可以了。成功，这里substr也有三个参数，第一个为要匹配的序列，第二个为开始的位置，第三个为匹配的长度。 这里我们自然而言地想到，可以截取出一段序列，那么将它替换成其他序列便是举手之劳：实际上，这里的substr功能完全可以用正则表达式来实现，本次不作介绍。 我们再看看处理的序列由碱基ATCG组成，对于生信工作者而言，把他转换成互补序列，反向序列，反向互补序列也应该成为正常需求。其中反向序列，很好实现，用reverse函数即可，而互补序列用正则表达式的转换功能tr即可(正则表达式有三种模式，匹配，替换，转换)，反向互补序列把得到的互补序列reverse即可： 那么我们再进一步，如何分割字符串呢？用split函数，实际上到了这里我们发现，perl语言中的命令完全就是日常用语，可能原因是，perl的发明者本身就是语言学家，那么设计语言时最好满足自然语义。首先创建一个逗号分隔的字符串，然后尝试几种split分隔的模式及其返回的结果，学习perl语言光看书不行，必须要动手操作，在一个终端里面即时反馈，错了就调试。split的基本用法就是两个参数，返回的是数组，从\@split4可以看出来(4)，如果使用标量上下文返回的是数组元素的个数(1)，如果在末尾加上第三个参数，数字参数，就是限定最终切割的个数，如果是1就是不切割(2,3)，因为split返回的是数组，所以可以使用 []访问数组中的元素(6,7,8,9)，还可以同时命名三个标量，分别赋值见ABC。 我们可以分割字符，也可以让他们再次连接在一起，而且可以定义连接的方式使用join函数；实际上split和join就是相反的过程： 此时，那些基本的求序列长度，去掉序最后一个字符，字符大小写转换，首字母大小写也需要一并掌握，实际上这时候会感觉很简单： 一开始序列长度为56，使用chop切掉末尾的T后只剩下56个，使用lc转换成小写，再使用uc转换成大写，使用lcfirst将首字母小写，使用ucfirst将首字母大写，最后尝试了另外的转换大小写的方式。 ##sort排序功能特别重要perl提供了飞碟操作符： \$a &lt;=&gt; \$b 数字大小排序 \$a cmp \$b 字母顺序排序 数字排序：使用sort直接排序并不能按数字大小排序字母排序：借助字母的排序我测试了几种排序的方法以实现不同的效果通过测试，我发现： sort和cmp效果相同(1-2) 四种忽略大小写的方法都可以实现相同的结果(3-6) 调换\$a和\$b的位置可以实现和reverse一样的功能(7-8) 对sort后的数组再用cmp排序可以实现按字母排序，并且大写字母在前(9) 我想怎么实现小写字母在前呢？在9的基础上，增加判断语句，当两个字母相同时，让小写字母在前面(10) 借助10的结果，学习一下\$a cmp \$b以及 \$a &lt;=&gt; \$b的功能，实际上他们是sort的一个参数我们先看一下sort的用法 直接使用,就是sort @array 自定义排序sort {sub rule} @files{}中就是排序的原则，\$a &lt;=&gt; \$b的意思就是按数字从小到大排序，\$a cmp \$b就是按字母顺序排序，\$，\$b是系统的全局变量，我们记住有这样的用法即可，其中\$a cmp \$b以及 \$a &lt;=&gt; \$b是有返回值的。此时我们再来理解10的表达式，如果前面两个字母相同，那么返回值就是0，or和||的意思就是如果前面是假则执行后面的程序。这种方法在hash的排序中也有广泛的使用。 ##关于hash的排序准确的说，hash是不能排序的，能够排序的是hash的键名和键值我们先按照键名来排序：实际上生活中更常见的是按照分数从大到小排序，用\$score{$a},表示键名对应的键值：我们发现，95分有两个人，我们希望当分数一样的安装名称的字母排序 我想我应该已经入门perl字符串的处理了。]]></content>
      <categories>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>Perl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可能是最好用的TCGA数据库GEPIA]]></title>
    <url>%2F2017%2F10%2F18%2F09-GEPIA%2F</url>
    <content type="text"><![CDATA[听生信群里大神闲聊，说他自己的师弟做了个TCGA可视化工具，我就点开链接看了一下，不点开就算了，一点开不得了，就像我手上的锤子手机，千万别用，用了就无法回头。 TCGA相关的数据库有很多，但我最关心的功能只有三个，差异表达，生存分析，相关性分析，这也是我筛选课题的一个方向 能够差异表达是前提 如果这时候还跟生存相关，那就锦上添花了， 通过相关性分析找出他的朋友们，所谓物以类聚，看看这个人的朋友基本上就知道他是什么样子的人， 有一个恐怖的传说一直让我后背冒汗心里起火：你的工资是跟你密切交往的6个朋友的平均值，朋友居然重要到这个层面。 好了，不鬼扯，我们简单介绍一下这个数据库GEPIA（Gene Expression Profilling Interactive Analysis），翻译一下应该是基因表达谱数据动态分析。 http://gepia.cancer-pku.cn/index.html这个数据库是北京大学开发的，没有发文章，没有发文章。 This tool is developed by Zefang Tang, Chenwei Li and Boxi Kang of Zhang Lab, Peking University. 我要学学宝剑叔叔右哉，先拟定一个让你痛心的场景，蓝后一步一步帮你解决, 这可能有助于我们直接解决问题。假设， 你现在已经研二了，之前放浪形骸，行散神也散，现在木有课题，木有鱼丸，明年要毕业了，蓝后没有管你也没有男女朋友，没有大师兄，没有沙师弟，你该怎么办呢？ 我们可以这样，先找出某个特定癌症中跟生存最相关的一串基因，再来慢慢筛选，正好GEPIA有这个功能。先点击一下Survival Analysis，依次点击 用下面的方法也是一样的。还要简单一点。 点击list会出现下面的结果，可以查询，可以翻页，可以一个个复制粘贴用以前讲的方法做GO分析，KEGG分析，互作分析。 这里我们直接选择VADC1来看看，首先我们检查一下这个基因分生存分析图究竟是什么样子，点击它这时候相当于进入了单基因入口，这里面给出了这个基因概括，说是线粒体膜的主要组成成分，也跟铁的转运相关，我觉得都是热门方向如果这个领域你hold不住，就返回去再换一个基因点进来，最右边图我觉得很直观，绿色代表VDAC1在正常组织的表达，红色代表在肿瘤组织中的表达可能这张图看不出啥特殊，我举个例子， A基因几乎只在乳腺表达，而且在乳腺癌中明显高表达B基因在全身广泛表达，但是表达风度不高，而在乳腺癌中表达显著提高 好了页面往下拉就可以看到这个基因在多个癌症癌和癌旁的表达情况，我们可以看出他在乳腺癌中是高表达的但是在其他许多癌症中也明显差异表达，这张表不会让你漏掉其他癌症，如果恰巧实验室有人在做那个癌症，你就可以跟他合伙搞一搞嘛。因为你没有人管，没有大师兄，没有沙师弟，你还有什么选择？此外，你是可以选择呈现方式的，按照如下步骤操作可以得到漂亮的癌和癌旁的表达图 点击plot之后是这个样子的，可以下载，可以直接放在文章里面返回一开始的界面，往下面翻一翻就会看到和这个基因表达类似的基因 哎呦歪，里面HNRNPAB就是核内不均一核糖核蛋白家族成员，他可是要调控RNA的可变剪切的，许多LNCRNA作pulldown后就会拉下这个家族的成员相关的文章从SCIENCE，CELL到ONCOTARGETS都有。 但是我们差点忘了进来是干什么的，我们是来看生存分析的。依次操作。 点击plot就会得到下面的图这个图真的是漂亮，一点都不含糊，好了这时候课题基本上就有苗头了 VDAC1以暂时不知道的原因升高导致乳腺癌的发生，而乳腺癌患者高表达VADAC1的患者低生存， 而临床医生做科研不外乎诊和疗 从诊治的角度来说，这个基因表达水平对诊断乳腺癌有没有帮助？ 从治疗的角度来说，既然高表达低生存，那么有没有可能设计抗体来治疗乳腺癌呢？ 当然那个是转化医学，在这之前就是基础医学从研究的角度来看： 这个基因高表达的原因是什么？表观遗传相关么，突变么，转录激活么，翻译修饰么，搞清楚就已经不容易了。我们试一试表观遗传有没有影响，在UCSC数据库中打开VDAC1，我的妈呀，他的启动子区域这么汹涌澎湃的H3K27ac修饰，说明他的表达量本身就很高，不大可能是个坏分子，要么就是他在癌中突变了，要么就是他启动子在癌症中被过度激活了，我只是说可能那么就会有个子课题产生： H3K27ac组蛋白乙酰化修饰促使VDAC1基因启动子激活从而升高其表达 另外一个问题，这个基因在乳腺癌中的功能是什么？可以尝试用生物信息学找到共表达的基因，之前已经列出来了，再去预测他可能有什么功能，也可以直接构建慢病毒shRNA敲减后看看他的表型，可是这不是你想要的，我们需要的是短平快，怎么办呢？查文献，恰好我刚知道那个写过Hallmars of Cancer这篇文章老爷爷Weinberg在nature发表了一篇文章，时间是2017年3月30日，他们找到了乳腺癌中一个新的抑癌基因叫做LACTB，他能够调控脂质代谢抑制乳腺癌，LACTB是一个线粒体相关的蛋白，VDAC1也是一个线粒体相关的蛋白，他们之间可能有联系么？他们的联系可能多种多样，我们尝试用现成的工具看一下，相关性分析点击plot试一下居然他们还有相关性，欢天喜地庆丰收，毕业在望。可是他们他们应该表达呈负相关才合理呀，这么来把这些结果整合到一起呢？VDAC1和LACTB相关，抑制癌症的产生，蓝后不知怎么的他的启动子就过度活化了然后他就促发了癌症？我觉得自己都说服不了，我们还是换一种思路吧，用string数据库来看一看VDAC1居然跟BAX，BCL2L1相关，表明其可能跟细胞的凋亡相关 好了最终的课题就是H3K27ac修饰使VDAC1的启动子过度乙酰化促进其表达从而抑制细胞凋亡促进乳腺癌的发展。我觉得这时候真的可以搞一搞了，什么，你没有shRNA？不是说了跟别人合作么，你怎么又搞忘了。蓝后检索一下VDAC1和乳腺癌的文章，发现少之又少，开始吧。这个过程中好像文献阅读并不重要，但是不要忘了LACTB是Weinberg文章里面的LACTB在乳腺癌中的表达和调控还没有研究呢，上面那个课题要是实在弄不好，就换这一个吧。Note: 表观遗传那一块我是不严谨的，应该选乳腺的数据看看修饰，ENCODE数据库就支持。蓝后，我觉得科研结果的呈现最基本的要求就是 ##自洽四个字就是自圆其说，不要前后矛盾，你自己构建了一个体系，一定要让自己信服。自己都不相信的东西还想让别人相信，你把我当什么了。]]></content>
      <categories>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>TCGA</tag>
        <tag>GEPIA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 安装后要做的事]]></title>
    <url>%2F2017%2F10%2F18%2F08-linux-apply%2F</url>
    <content type="text"><![CDATA[组装了服务器，又装上了系统，会使用编辑器，我马上就想开始RNA-seq的练习，但是在这之前，有一些事情需要完成。首先要知道如何进入linux的终端，当我没说。 ##知道基本的linux命令 ls,pwd,cd, cat,less,vim pwd查看当前目录 ls查看目录下的文件 cd 切换目录，tab键可以自动补齐详细的可以读一读生信菜鸟的帖子教你如何轻松入门Linux，我把它放在了阅读原文里面。 ##配置SSH虽然我为linux配置了一块屏幕，实际上工作中并不需要，我们用笔记本ssh到服务器，然后直接在自己的笔记本电脑上操作就行了#号表示root权限，$表示普通权限，这两个符号不需要输入。切换root 和普通用户使用命令：12su root #普通转rootsu 用户名 #root转回普通用户，注意大部分时间是在用普通权限，不需要使用root账户分析数据，因为linux认为权限越大，责任越大，你使用root删除资料是没有人提醒你的，删了就是删了。 终端中输入：1# vim /etc/ssh/sshd_config 上一次已经说了vim的基本使用，把下面文字前面的#号去掉 Port 22 Protocol 2保存退出，再输入：1# /etc/init.d/sshd restart 使用命令1ifconfig 找到类似于192.168这样的地址,然后记住自己的账户名和登录密码使用putty或者xshell即可使用笔记本远程登录自己的服务器此时服务器可以不用关机，屏幕也可以不要了。注意，这里的远程登录，范围大小只是路由器的辐射范围，不能异地远程登录，如果想要实现异地远程登录，即在家使用实验室的服务器，需要服务器有固定IP，而固定IP很贵，买不起，如果没有可以尝试用下面的方法实现。 路由器端口转发 具体过程可以查询解决方案，这时候要注意，一旦路由器断电，或者重启，路由器会获得一个新的IP，这时候需要重新设置，才能继续使用。如果需要再服务器和windows电脑上交换文件，推荐使用windows端的winscp软件，很好用。 ##修改SELinux配置打开SElinux会导致一些生物信息软件安装不了，所以将他关闭1# vim /etc/selinux/config 输入下面文字： SELINUX=disabled##安装GCC我们安装的Centos6.5里面含有的是低版本的GCC，而有一些生物信息软件的安装需要高版本的GCC，这一次我们的任务是安装一个高版本的GCC，并且与系统自带的GCC共存。GCC是个编译工具。Linux系统下的GCC（GNU C Compiler）是GNU推出的功能强大、性能优越的多平台编译器，是GNU的代表作品之一。gcc是可以在多种硬体平台上编译出可执行程序的超级编译器，其执行效率与一般的编译器相比平均效率要高20%~30%。其实到目前为止我也搞不清楚，但是我会装，会用。123456789101112131415161718sudo mkdir /opt/biosoft /opt/sysoft/ #使用root权限在opt下创建biosoft和sysoft文件夹，以后大部分软件安装在biosoft里面，本次高版本GCC软件安装在syssoft文件夹sudo chmod 1777 /opt/biosoft /opt/sysoft/ #使用root修改文件夹的权限wget http://mirrors-usa.go-parts.com/gcc/releases/gcc-4.9.3/gcc-4.9.3.tar.bz2 -P ~/software/ #下载高版本GCC到software文件夹tar jxf ~/software/gcc-4.9.3.tar.bz2 #打包解压cd gcc-4.9.3/ #转到这个目录./contrib/download_prerequisites# 下载相应的依赖软件sudo yum install glibc-devel.i686mkdir ../gcc-buildcd ../gcc-build../gcc-4.9.3/configure --prefix=/opt/sysoft/gcc-4.9.3 --enable-multilib --with-system-zlibmake -j 8 #8线程编译make installcd ../ &amp;&amp; rm gcc-build/ gcc-4.9.3/ -rfecho &apos;export PKG_CONFIG_PATH=/opt/sysoft/gcc-4.9.3/lib/pkgconfig:$PKG_CONFIG_PATH&apos; &gt;&gt; ~/.bashrc.gccecho &apos;export LD_LIBRARY_PATH=/opt/sysoft/gcc-4.9.3/lib64:/opt/sysoft/gcc-4.9.3/lib:$LD_LIBRAR\ Y_PATH&apos; &gt;&gt; ~/.bashrc.gccecho &apos;export C_INCLUDE_PATH=/opt/sysoft/gcc-4.9.3/include:$C_INCLUDE_PATH&apos; &gt;&gt; ~/.bashrc.gccecho &apos;PATH=/opt/sysoft/gcc-4.9.3/bin/:$PATH&apos; &gt;&gt; ~/.bashrc.gccsource ~/.bashrc.gcc ##安装Python 2.7.11 版本有的软件执行需要Python123456789wget https://www.python.org/ftp/python/2.7.11/Python-2.7.11.tgz -P ~/software/tar zxf ~/software/Python-2.7.11.tgzcd Python-2.7.11/./configure --prefix=/opt/sysoft/Python-2.7.11/make -j 8make installcd .. &amp;&amp; rm Python-2.7.11/ -rfecho &apos;PATH=$PATH:/opt/sysoft/Python-2.7.11/bin/:$PATH&apos; &gt;&gt; ~/.bashrcsource ~/.bashrc ##安装pip，用于安装Python需要的依赖软件12345678910wget https://pypi.python.org/packages/45/5e/79ca67a0d6f2f42bfdd9e467ef97398d6ad87ee2fa9c\ 8cdf7caf3ddcab1e/setuptools-23.0.0.tar.gz -P ~/software/Python_modules/tar zxf ~/software/Python_modules/setuptools-23.0.0.tar.gzcd setuptools-23.0.0//opt/sysoft/Python-2.7.11/bin/python setup.py installcd .. &amp;&amp; rm setuptools-23.0.0 -rfwget https://pypi.python.org/packages/e7/a8/7556133689add8d1a54c0b14aeff0acb03c64707ce1\ 00ecd53934da1aa13/pip-8.1.2.tar.gz -P ~/software/Python_modules/tar zxf ~/software/Python_modules/pip-8.1.2.tar.gzcd pip-8.1.2//opt/sysoft/Python-2.7.11/bin/python setup.py installcd .. &amp;&amp; rm pip-8.1.2 -rf ##CentOS下安装软件的常用方法这部分整理自笔记，来源不清楚，也可以看完这部分内容再去完成上面的操作，主要是帮助立即。 1.一种是软件的源代码，需要自己动手编译它。这种软件安装包通常是用gzip压缩过的tar包（后缀为.tar.gz）。 2.另一种是软件的可执行程序，只要安装它就可以了。这种软件安装包通常被是一个RPM包（Redhat Linux Packet Manager，就是Redhat的包管理器），后缀是.rpm。##对于需要编译的第一种，分两个部分：###第一部分：.tar.gz首先，将安装文件拷贝至你的目录中。例如，如果你是以root身份登录上的，就将软件拷贝至/root中。1#cp filename.tar.gz /root 由于该文件是被压缩并打包的，所以，应对其解压缩。命令为：1#tar xvzf filename.tar.gz 执行该命令后，安装文件按路径被解压缩在当前目录下。用ls命令可以看到解压缩后的文件。通常在解压缩后产生的文件中，有名为”INSTALL”的文件。该文件为纯文本文件，详细讲述了该软件包的安装方法。对于多数需要编译的软件，其安装的方法大体相同。执行解压缩后产生的一个名为configure的可执行脚本程序。它是用于检查系统是否有编译时所需的库，以及库的版本是否满足编译的需要等安装所需要的系统信息。为随后的编译工作做准备。命令为：1#./configure 如果检查过程中，发现有错误，configure将给予提示，并停止检查。你可以跟据提示对系统进行配置。再重新执行该程序。检查通过后，将生成用于编译的MakeFile文件。此时，可以开始进行编译了。编译的过程视软件的规模和计算机的性能的不同，所耗费的时间也不同。命令为：1#make (make -j 4 这是以四线程来编译) 成功编译后，键入如下的命令开始安装：1#make install (sudo make install) 安装完毕，应清除编译过程中产生的临时文件和配置过程中产生的文件。键入如下命令：12#make clean#make distclean 至此，软件的安装结束 ###第二部分1.首先，使用tar -xzvf来解开这个包，如：1#tar -xzvf apache_1_3_6_tar.gz 这样就会在当前目录中创建了一个新目录(目录名与.tat.gz包的文件名类似），用来存放解压了的内容。如本例中就是apache_1.3.62.进入这个目录，再用ls命令查看一下所包含的文件，如：12#cd apache_1.3.6#ls 你观察一下这个目录中包含了以下哪一个文件：configure、Makefile还是Imake。 1.如果是configure文件,就执行： 123#./configure#make#make install 2.如果是Makefile文件,就执行： 12#make#make install 3.如果是Imake文件,就执行： 123#xmkmf#make#make install make原理是执行一个叫(所生成的)Makefile文件里的指令，make的基本用处是自动根据makefile里的指令来编译源文件。它还可以用来做比如安装软件，卸载软件等事情，但前提是作者在makefile里写了。比如makefile里有这么些内容：install : &lt; commands &gt;然后用make install的话，make程序就会按照上面install：后面的指令&lt; commands &gt;执行安装，uninstall也是一样的道理，大部分的作者会写有卸载的部分，这时只要简单地执行make unistall就可以，如果作者懒没有写，那就只有根据make install中的步骤，看它把什么文件拷到哪去了，然后分别手动删除。还有关键的一点是，编译安装完成后，不要删除源代码，不然就算作者写了unnistall目标，你也没有makefile可以执行了。3.如果没有出现什么错误提示的话，就搞定了。至于软件安装到什么地方，通常会在安装时出现。否则就只能查阅一下README。 ##第二种：.rpm RPM是Red Hat公司随Redhat Linux推出了一个软件包管理器，通过它能够更加轻松容易地实现软件的安装。将安装文件拷贝至你的目录中/usr/src。然后使用rpm来安装该文件。命令如下：1#rpm -ivh filename.i386.rpm rpm将自动将安装文件解包，并将软件安装到缺省的目录下。并将软件的安装信息注册到rpm的数据库中。 1.安装软件：执行rpm -ivh rpm包名，如： 1#rpm -ivh apache-1.3.6.i386.rpm 2.升级软件：执行rpm -Uvh rpm包名。 3.反安装：执行rpm -e rpm包名。 4.查询软件包的详细信息：执行rpm -qpi rpm包名 5.查询某个文件是属于那个rpm包的：执行rpm -qf rpm包名 6.查该软件包会向系统里面写入哪些文件：执行 rpm -qpl rpm包名##终于可以开始RNA-seq分析啦！！]]></content>
      <categories>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编辑器之神VIM的使用及配置]]></title>
    <url>%2F2017%2F10%2F17%2F07_vim%2F</url>
    <content type="text"><![CDATA[做生信要写代码，写代码就需要编辑器，在linux系统下有一款编辑器不能被忽略，就是VIM，江湖人称编辑器之神。当然，在一堆程序员里面千万不要讨论语言的好坏，也不能突然冒一句perl是世界上最好的脚本语言，不能，千万不能，要不然死的很难看。 所以讨论编辑器时也不能随便说哪个最好，人们常说vim是编辑器之神，继而又说他的对手emacs是神的编辑器。绕来绕去就是为了一个名分，所谓树争一身皮，编辑器争一口气。VIM用好了以后的状态是这样子的： 写过程序的人都知道，编程的时候双手大部分时间都放在键盘上，或编码、或插入、或移动、或定位、或查找，这种连续操作的时间和频率远远大于阅读、翻页、设置字体、摆弄样式等文案工作，而二者往往产生很多停顿和间隙，而编程时的停顿是非常影响编程效率的，所以 Vim 的设计理念就是通过模式的转换、命令的组合和不计其数的插件，保证程序员在编程的过程中，双手尽可能保留在键盘中央的区域，并且，不需要鼠标。 大多人看不起VIM的原因可能有一个：VIM上手容易，但学习曲线陡峭，很多人没有学会就放弃了。这不是我说的，是池建强老师说的。VIM的故事和详细用法可以查看池建强老师写的VIM系列，最终他把这个系列写成了一篇长文，说，谁才是最帅的编程工具？十分精彩，我觉得可以去读一读。微信不能外部链接，我把他放在了阅读原文里面。VIM内置在linux系统下，在命令行输入 vim 然后enter键，就可以看到vimvim的上手很简单，他有四种模式 普通模式：Vim 启动后的默认模式，用来移动光标、删除文本、覆盖输入文本、恢复操作、粘贴文本等等。 插入模式：输入 i 或 a 进入插入模式，在这个模式下敲击键盘会往文字缓冲区增加文字，相当于普通编辑器的编辑模式。 可视模式：选择文本，可以行选、块选和依次选择，选择后可以进行复制、删除、排序等操作。 命令模式：执行内部和外部命令，通过「: / ? !」可以进入命令模式，分别对应的是：执行内部命令、向上或向下搜索、执行外部命令。 假设我们写个名字叫11的perl程序，直接在命令行输入vim 11.pl enter键就OK了1vim 11.pl 接着我们按一下a或者i就进入插入模式，这时候在就可以通过键盘随便输入了，你打字的时候看一下左下方会有insert字样假设我们现在已经写完程序，想要保存退出怎么办呢？按esc键切换到命令行模式，同时按shift+：，就是shift键和冒号一起按，这时候左下角会出现冒号标志输入wq就是保存退出输入q！就是不保存直接退出注意，如果操作不了，一定要确定正在使用的是英文输入法这样就已经学完了 这时候要想到vim是效率神器，而且不需要鼠标就可以方便的复制粘贴，跳跃，所以接下来会有很多命令要学，我自己掌握的也不好，就不献丑了，至少我已经在用了，perl程序全是使用vim写的。 现在有个问题就是vim不好看，虽然不需要鼠标，全键盘操作，但我觉得界面太丑，没有电影里面那种花花绿绿代码齐发的感觉，现在我知道那个叫语法高亮，所以我又查了一下vim的配置。 很多时候长大了那些执念就是为了完成小时候未完成的心愿。 ##VIM的配置切换到家目录1cd ~ 创建.vimrc文件1vim .vimrc 进入插入模式，复制下面代码，右击鼠标粘贴，不能是使用ctrl+V1234567891011121314151617181920212223242526272829filetype onsyntax onset nuset cindentset rulerset tabstop=4set softtabstop=4set expandtabset shiftwidth=4set backspace=indent,eol,startset completeopt=preview,menuset cursorlineset magicset autoindentset smartindentset showmatchset history=1000set nobackupset noswapfileset ignorecaseset hlsearchset incsearchinoremap &apos; &apos;&apos;&lt;ESC&gt;iinoremap &quot; &quot;&quot;&lt;ESC&gt;iinoremap ( ()&lt;ESC&gt;iinoremap [ []&lt;ESC&gt;iinoremap &lt; &lt;&gt;&lt;ESC&gt;iinoremap &#123; &#123;&#125;&lt;ESC&gt;iset guifont=Bitstream_Vera_Sans_Mono:h10:cANSI 好了现在使用编辑器就有那种花花绿绿的感觉了，这是我写的一个perl程序：]]></content>
      <categories>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硬盘上写的6Gb/s是什么意思]]></title>
    <url>%2F2017%2F10%2F17%2F06-6GB%2F</url>
    <content type="text"><![CDATA[上次我讲到如何在家里组装一个服务器，这时不可避免地会购买硬盘，如果追求大容量，就绕不过机械硬盘，实际上无论如何也绕不开机械硬盘，我在购买硬盘的时候 ，观察到硬盘上会写有这样的标志，6Gb/s。实际上这个标志我看了很多遍，直到我配置服务器时才注意到。 学习一项新的技能，看世界就多了一个维度，这种感觉就像刚背了单词，再去做题时总是会碰到，刚买了新车，发现满大街都是一样的车。但是呢，单词就在那里，没有变过，汽车就在街上，不增不减。改变的是我们的注意力，扩增的是知识结构，从此那些相关的点就会自动填充进来。 我的使用经验告诉我，没有哪一个硬盘达到过这个速度，即使是我特别喜欢的固态硬盘也远远达不到这个要求，那么这个6Gb/s是啥意思呢？ 我回家后查阅了一些资料，暂时的理解是这样子的：SATA（Serial ATA）口的硬盘又叫串口硬盘，是未来PC机硬盘的趋势，现已基本取代了传统的PATA硬盘。SATA的优势：支持热插拔 ，传输速度快，执行效率高。 SATA分为SATA1.0和SATA2.0和SATA3.0，最大传输速度分别是150M/s和300M/s和600M/sSATA3.0又叫SATA 6GB/s接口，这个所谓接口速度6GB/s，6GB/s=1024M*6/s=6144M/s≈6000M/s，然而上文提过，SATA3.0最大传输速度600M/s，看起来是矛盾的，但是我们要注意，6Gb/s的b是小写，而GB，MB的B是大写， 这两个b的意思不一样！！！！！6Gb/s = 6 Giga-bits /second bit(s) = 比特位，缩写bByte(s) = 字节，缩写B 比特位（bit）来自英文bit，音译为“比特”，表示二进制位。位是计算机内部数据储存的最小单位，11010100是一个8位二进制数。一个二进制位只可以表示0和1两种状态（21）；两个二进制位可以表示00、01、10、11四种（22）状态；三位二进制数可表示八种状态（23）……。 字节（byte）字节来自英文Byte，音译为“拜特”，习惯上用大写的“B”表示。字节是计算机中数据处理的基本单位。计算机中以字节为单位存储和解释信息，规定一个字节由八个二进制位构成即1个字节等于8个比特（1Byte=8bit）。八位二进制数最小为00000000，最大为11111111；通常1个字节可以存入一个ASCII码，2个字节可以存放一个汉字国标码。 1Byte = 8bits 所以1Gb = 1/8 GB=128 MB 也就是说6Gb/s = 6/8 GB/s = 0.75 GB/s = 750 MB/s， 1B=8b。但是硬盘是8/10传输。每10位里只有8个数据位，2个校验位。所以虽然传输了10b但是只有8b是数据。所以要打8折，所以6Gb/s得最终得传输数据速度是750乘以0.8=600MB/s而这个600是理论上的最大值，实际上在传输过程中还有约10%的损耗，所以最终，大概传输速度是600乘以0.9=540M/s,这还是固态硬盘的速度，所以世面上的固态硬盘大多说自己的最大速度是550M/s，真实速度大概是200M/s左右。 如果换成机械硬盘，SATA 6Gb/s的意思只是说这个硬盘支持的接口是SATA3，并不代表他的速度。机械硬盘真实的传输速度大概是40M左右。 所以，6Gb/s只是告诉我们这个硬盘是SATA3接口，不要想多了,不要想多了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[临床医生的服务器组装记录]]></title>
    <url>%2F2017%2F10%2F17%2F05-server-self-made%2F</url>
    <content type="text"><![CDATA[写于2017年1月7日我在想为什么可以学会芯片分析，但总学不会RNA-seq？ 答案：芯片分析只要是台电脑就可以上手，但是RNA-seq，没有一台像样的服务器，谈何容易。 于是我就准备从头组装一台服务器。 结果：组装成功并用了三天入门RNA-seq。 首先最恐怖的问题： 电脑零基础能组装自己的服务器么？我问了一下Jimmy，他说，刚好有个小伙伴自己组装了一台工作站，你可以参考下，我说，把配置清单给我： 1.cpu 至强E5-2683-v3 1个 2.内存64g，DDR4-RECC 3.主板微星99A RAIDER 4.硬盘: 希捷2T机械硬盘， 5.三星960 EVO 256g固态硬盘 最终我也联系到了那位小伙伴（广西医科大学），发现他把配件买齐后，已经配置好了，所以这个事情给了我很大信心。和优秀的人在一起，视野会开阔许多。好吧，其实这时候不担心会不会组装，担心的是这样的配置，能不能带得动RNA-seq以及其他的生物信息分析。我就问了一下暑假学习的老师（陈连福老师），他说你这个够用，但是作为专业的生信工作人员，你得上四路，4个CPU，内存要大（256g起步），硬盘要大（4T起步），机器要专业，价格要公道。我说，说那么多，没用，我预算就这么点钱，您比着给个建议吧他说，我觉得我自己组装的这个DL580G7服务器就挺好，4个CPU，40核80线程，256g内存，所有耗材都是在某宝上攒的，共花费16000。后面问了下业内人士，这么点钱搞下来的都是高手。我就说，你给我配置清单呗： E7-4870 4个 内存 8g乘以32条=256g DL580G7 主板 带笼子（来自退伍专业服务器） 硬盘 2T乘以4 电源 4个 内存扩展板 4个 风扇我拿着清单去某宝查了一下，确实搞不下来，更主要的原因就是我对这个东西一点都不懂。专业的事情交给专业的人来做，我就问他，能不能付费给你，你帮我搞一个一样一样的，他说可以，但是组装服务器有风险，cpu点亮是个难题，来回调货很耗时间，组装好了调试也花时间，但是我的可以直接卖给你，但是要加收服务费，我说好，接受！但是最后因为时间的问题以及我要把他放在家里（专业的放在家里不合适），我决定自己组装，这也是学习的过程。就参照一开始广西医科大学那位朋友单个CPU的配置。首先我有了4路这个概念，所以我折中选择双路，我自己觉得更新获取新的概念很重要，很多时候我们懵逼多半是因为脑子里面完全没有这个概念而已，比如在组装的过程中我又知道了RAID模式，磁盘阵列卡等概念。 李笑来说过，人与人之间的差异就是正确的概念量的大小。既然选择了双路，我也懒得换CPU，就用那个E5-2683-V3，买两个就行。 CPU：Intel/Xeon E5-2683-V3 正式版CPU 原装散片 14核心28线程（2个） 可是这时候问题来了，双路是需要主板支持的，所以我又看了一下双路的主板，这时候我的脑子里面已经有了兼容这个概念，所以我就检索能够支持E5-2683-V3的双路主板，最终找到了这个 主板：全新超微X10DAI LGA2011-3 C612 双路E5-2600V3V4 图形工作站主板这个主板支持16根内存插槽，方便以后升级。然后我又注意到这个主板写了支持的机箱，我才知道，原来主板换了，也要换机箱，我看到这家店里也卖机箱，专业的服务器机箱，我说就在你家买，你把主板和机箱配好了再给我寄过来吧，最后在店家的提醒下，又买了两个cpu的风扇。 机箱：超微SC745TQ-920B 图形工作站塔式机箱 920W电源 8*SATA热插拔 CPU风扇：DIY组装网烁WASO 3U2011 五热管 四线侧吹静音工作站散热器 两个现在最重要的就是内存，问了一下群里的朋友，人家直接回复说，DDR4，RECC，2333频率，其实我也不懂这些是什么东西，我也不关心参数什么的。专业的事情让专业的人来做，我听就行了。随即跟电脑城的朋友联系，买了4根三星的内存 内存：三星专业服务器内存 DDR4 RECC 16g 4个其实到了这一步，一个服务器的框架基本就形成了，除了硬盘啥都可以不要。但是我同时考虑到一个问题，万一，我是说万一，将来不做生物信息学分析，这个机器怎么办呢？我想我能不能给他配点东西让他能够输入，输出，当一台强大的家用电脑用呢？所以我又买了一块显示屏： 显示屏：三星C27F591FD 27英寸新品曲面1800R曲率液晶又买了一个键盘， 机械键盘：海盗船K65红轴买了个鼠标 鼠标：Logitech/罗技MX MASTER无线大师鼠标 蓝牙优联双模式鼠标我想用另一块硬盘装windows系统和黑苹果系统，而且我之前也体会到了固态硬盘的威力 固态硬盘：Intel SSD 256g 1个后来又了解到我的主板没有集成显卡，我想到后面要处理图片，所以又整了个入门级别的专业图形卡 显卡：丽台Quadro K620专业设计图形工作站绘图2G显卡这个图形卡支持双接口，DP接口和HDMI接口，考虑到我的笔记本电脑是HDMI接口，所以又购置了一根DP线用于连接服务器 绿联发烧款 dp线4K高清DP1.2连接线公对公Dell hp displayport线考虑到实验室网速太慢，准备把机子放在家里面，但是只能用WiFi，所以又买了个无线网卡，考虑到后面要安装黑苹果系统，所以选的是不需要安装驱动的网卡 无线网卡：Fenvi无线网卡台式机pci-e AR9280双频5G 300M+300Mac免驱这时候我扛着在网上买来的的东西去电脑城找人安装，我想自己查一查网络也可能学会，但是我不喜欢这样做，这需要学习成本，而且专业的事情要交给专业的人来做，对我来说，最需要的是，生信练习，我巴不得有人能够直接把服务器放到我家里，我打开电脑就能用，这时候我根本不想体验动手的乐趣。电脑城的朋友恰巧收购了一台惠普二手的服务器，就把上面的光驱和硬盘卸载下来卖给了我。 硬盘: 惠普2T 7200转 两块 光驱: 惠普原装讲到硬盘这里还有个小插曲，为还专门写了一段:…我在购买硬盘的时候 ，观察到硬盘上会写有这样的标志，6Gb/s。实际上这个标志我看了很多遍，直到我配置服务器时才注意到。 学习一项新的技能，看世界就多了一个维度，这种感觉就像刚背了单词，再去做题时总是会碰到，刚买了新车，发现满大街都是一样的车。但是呢，单词就在那里，没有变过，汽车就在街上，不增不减。改变的是我们的注意力，扩增的是知识结构，从此那些相关的点就会自动填充进来。 我的使用经验告诉我，没有哪一个硬盘达到过这个速度，即使是我特别喜欢的固态硬盘也远远达不到这个要求，那么这个6Gb/s是啥意思呢？我回家后查阅了一些资料，暂时的理解是这样子的：SATA（Serial ATA）口的硬盘又叫串口硬盘，是未来PC机硬盘的趋势，现已基本取代了传统的PATA硬盘。SATA的优势：支持热插拔 ，传输速度快，执行效率高。SATA分为SATA1.0和SATA2.0和SATA3.0，最大传输速度分别是150M/s和300M/s和600M/sSATA3.0又叫SATA 6GB/s接口，这个所谓接口速度6GB/s，6GB/s=1024M*6/s=6144M/s≈6000M/s，然而上文提过，SATA3.0最大传输速度600M/s，看起来是矛盾的，但是我们要注意，6Gb/s的b是小写，而GB，MB的B是大写， 这两个b的意思不一样！！！！！6Gb/s = 6 Giga-bits /second bit(s) = 比特位，缩写bByte(s) = 字节，缩写B 比特位（bit）来自英文bit，音译为“比特”，表示二进制位。位是计算机内部数据储存的最小单位，11010100是一个8位二进制数。一个二进制位只可以表示0和1两种状态（21）；两个二进制位可以表示00、01、10、11四种（22）状态；三位二进制数可表示八种状态（23）……。 字节（byte）字节来自英文Byte，音译为“拜特”，习惯上用大写的“B”表示。字节是计算机中数据处理的基本单位。计算机中以字节为单位存储和解释信息，规定一个字节由八个二进制位构成即1个字节等于8个比特（1Byte=8bit）。八位二进制数最小为00000000，最大为11111111；通常1个字节可以存入一个ASCII码，2个字节可以存放一个汉字国标码。 1Byte = 8bits 所以1Gb = 1/8 GB=128 MB也就是说6Gb/s = 6/8 GB/s = 0.75 GB/s = 750 MB/s，1B=8b。但是硬盘是8/10传输。每10位里只有8个数据位，2个校验位。所以虽然传输了10b但是只有8b是数据。所以要打8折，所以6Gb/s得最终得传输数据速度是750乘以0.8=600MB/s而这个600是理论上的最大值，实际上在传输过程中还有约10%的损耗，所以最终，大概传输速度是600乘以0.9=540M/s,这还是固态硬盘的速度，所以世面上的固态硬盘大多说自己的最大速度是550M/s，真实速度大概是200M/s左右。如果换成机械硬盘，SATA 6Gb/s的意思只是说这个硬盘支持的接口是SATA3，并不代表他的速度。机械硬盘真实的传输速度大概是40M左右。所以，6Gb/s只是告诉我们这个硬盘是SATA3接口，不要想多了,不要想多了。好的插曲结束…最终顺利地成功点亮CPU，在固态硬盘装上win10系统，我扛着这个80斤重的东西就回家了，就这样，对电脑一无所知的我配置了一台属于自己的服务器。回家装上CentOS系统，捣鼓了一通，现在，我已经入门RNA-seq了。百无一用是书生，人们常说，科研人员做那么多实验，在工作生活中有什么用呢？上了临床还需要那些RACE实验，pulldown实验干什么！实际上当我写完帖子后才发现，这次组装服务器的过程就跟我平常学习一个新实验的过程是一样的： 找到会做这个实验并且有成功经历的人并索取protocol（最初的配置清单） 通过店家的帮助更新概念修改protocol（主板和机箱卖家普及知识） 买齐耗材，开始实验，最好能请到会做的人演示一遍（电脑城的朋友组装）这么一想，心里踏实多了。好了现在你已经至少知道单路，双路，四路服务器的基本配置，已经可以开始上路了对于单路服务器，点击阅读全文，我们技能树论坛已经有小伙伴分享了详细的组装配置以及单价如果你觉得这样还嫌麻烦，那就对了在某宝上输入“图像工作站”或者“黑苹果”这样的词，已经有大量的团队帮你组装好，剁手下单，手起刀落，整个世界都沸腾了。 最后我还要温馨提示几件事情：1.最终我的服务器放在了实验室，为啥呢，双路服务器噪声太大，如果想要兼顾家用，考虑一下单路外加水冷静音。2.我最终并没有装黑苹果系统，为啥呢，双路难度太大，别人都不敢接单。3.不要过分考虑参数，你要是听过群主讲他们的服务器上了百万，你就知道我们这个不值一提，对我们而言，尽快地开始比什么都重要4.我使用的RNA-seq练习代码由下面的帖子提供。5.如果你是单位购买服务器，千万不要自己组装，直接买品牌套装，维修方便。]]></content>
      <categories>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCGA数据库大集合]]></title>
    <url>%2F2017%2F10%2F17%2F04-TCGA%2F</url>
    <content type="text"><![CDATA[虽然我现在有了自己的服务器，但是我觉得： 临床医生所理解的生信分析仅仅是数据库的使用，即使是数据库，大部分孩子也是知之甚少。 我把看过的帖子做一个合集，方便自己查阅看一个万事屋2015年6月25日对cBioPortal的介绍，那时你在干嘛呢？挖坟神器：TCGA的影分身再看看郭大侠一天之内如何挖掘4个TCGA数据库的基于TCGA蛋白芯片数据的分析神器如何从茫茫文献中挖掘出神器那一天我找到了基于TCGA的长链非编码神器Tanric，但是我并没有写贴这是之后出现的Tanric帖子lncRNA功能研究神器：TANRIC数据库lncRNA研究利器之”TANRIC”：一个探索癌症中lncRNA功能的交互式开放平台对于TCGA数据，生存分析是刚需，在Twitter上无意间发现了OncoLnc，生存曲线这种东西，还是用别人的好懒人怎么做肿瘤病人的生存分析？而如果你关注生信技能树这个公众号，你会发现还有一个神帖都可以批量做生存分析了，还要网页工具干嘛？说了这么多加入你还没有分子，可以尝试一下这里的方法：如何在不懂生信的前提下挖掘别人的数据？好烦！又要给你们推荐神器了……我就是用这神器随便挖一个TCGA福利就在今日-oncomine的用法oncomine是我的启蒙老师，需要教育邮箱，我想大部分孩子都没有想过去申请一个，而我可能是全校少数的申请者，当时管理员都忘了如何开通，眼神特别惊讶，而我的启蒙帖子是这样的还愁什么？前期工作就这么设计！假如你不会系统地挖掘数据可以看看这个：这是一个学生学习后的成果：盗墓笔记——如何用万事屋给的神器，不做实验挖掘乳腺癌相关标记基因？下面这个帖子意义重大，是郭猛老师的GEO课程，我认为这个可能是全网第一个大规模公开的GEO视频，是我R语言的入门老师，当时我赞赏了50块，之后又系统的学习了生信技能树群主的课程，特别好。GEO芯片数据下载与分析技巧（视频版）可能R语言有点不适应，你可以尝试用去年我给出的方案：代码芯片分析图文教程：每个人都可以做一做的生信第1题如果你研究甲基化，看看这个两个基因甲基化和表达如何实现一站式查询？这是一款有毒的神器网址http://mexpress.be/如果你对上面的都不感兴趣，试一下这个，这是我认为目前最好的TCGA可视化数据库，而我是全网第一个写帖子推荐的中国制造:碉堡的TCGA可视化网站GEPIA在这之前，我觉得看一下这个帖子是有益于身心健康的：课题设计：收不完的病人查不完的房，临床医生如何快速地设计一个靠谱的课题？]]></content>
      <categories>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>TCGA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些我学过的科研数据库]]></title>
    <url>%2F2017%2F10%2F17%2F03-database-learning%2F</url>
    <content type="text"><![CDATA[这里面大部分数据库我都使用过，但是遗憾的是，当年我并没有记录使用的感受，以及各个帖子对于新手的友好程度，甚至在使用某些数据库时，干脆自己把使用文档看了一遍，不过，没关系，你只要知道，想到达到什么目的该用什么数据库就可以了。 芯片分析： 其实这边跟TCGA帖子有点重合，说到底，数据挖掘有两个作用 没有课题的时候产生课题 没有机制的时候提供思路如何挖别人的数据，写自己的标书如何挖别人的数据，写自己的标书 II如何挖别人的数据，写自己的标书 3表达谱数据挖掘神器，一个就够！（上） 单基因信息汇总数据库： 通过TCGA帖子和前面的帖子，你已经有足够多的课题可以来做，但是如何筛选特定的基因，并确定自己的研究方向，你得看看下面的帖子研究单个基因的生物信息学分析工具还在为找不到基因序列而烦恼么？如何检索基因的DNA,mRNA,protein序列文献中基因挖掘的一个简单神器为啥要学习这些讨厌的蛋白互作分析工具？如何正确地寻找能扯上关系的明星分子告诉你文献聚类分析的神器 1告诉你文献聚类分析的神器2新神器get√，用这个来搜PubMed更深层次的文献分析神器Get√！偷懒的同学看好了，了解基因的捷径——gene card如何查询和展示一个基因在组织和细胞株里面的表达？人家五分文章是用这个神器来验证免疫组化的介绍一个来自全球最壕高校的数据库……（工具篇）S5E55：肿瘤耐药研究神器之——GDSC 转录调控相关： 我的导师告诉我，在90年代，包括现在，CELL杂志每期有一般的文章都是转录调控相关的，所以至今我们还保留在强悍得转录调控研究传统这里面包括如何找启动子，预测结合位点，转录调控的三驾马车你也应该知道：Luciferase，EMSA，ChIP，但是这些实验相关的知识不是本次的重点，再次挖坑。先看看我写过的帖子找出基因的启动子并分析其结合位点来，再教你搜个启动子吧……转录因子和靶基因系列（一）转录因子调控哪些下游基因，有实验证据的线索转录因子和靶基因系列（二）按类检索转录因子ChIP-seq数据转录因子和靶基因系列（三）哪个TF会来结合我这段DNA要是我有一堆基因，想知道他们的转录因子，要怎么整？十分钟设计一个转录因子相关的课题，坐稳了，装个逼给你看 表观遗传相关： 我们知道，人体内最终发货核心作用的是编码基因所对应的蛋白，而为什么拥有相同的基因组，心肌细胞和肝脏细胞差别那么大呢，一个是转录调控，另外一个重要的就是表观遗传。组蛋白修饰预示着什么？药物处理多久后能看到组蛋白修饰的变化？9分多的LncRNA相关的表观研究是怎么做的？跟着岳大师学ENCODE和RoadMap跟着岳大师学ENCODE和RoadMap（二）——利用ENCODE做特定分子的实验跟着岳大师学ENCODE和RoadMap（三）——如何分类查看转录因子并可视化分析ChIP-SeqWashU EpiGenome Browser的基本用法——跟着岳大师学ENCODE和RoadMap（四）如何神奇地用ENCODE挖课题 长链非编码RNA相关： 按照上面的说法，我觉得目前科研就围绕两个字进行，调控，转录调控，翻译调控，表观遗传，然而那些非编码RNA发挥越来越多的调控作用，这篇帖子要看看（文章篇）S5E53：标准化lncRNA课题设计但是我们同时看到，大部分团队对于长链非编码RNA的研究只是出于浅表状态，而我们理解的就是老老实实地做RACE确定全长通过RNA-pulldown确定结合蛋白，或者其他方法确定结合的DNA，ＲＮＡ，然后再证明如何起作用，好的文章只做了一件事情，把事情说清楚。然后再看看下面的帖子吧。如何预测LncRNA与蛋白的相互结合？你的lncRNA是否因SNP而发挥了不同的作用？导致预后的不同？要怎么证明LncRNA是LncRNA？！（工具篇）：神器之——lncRNA编码能力预测如何用BLAST来预测lncRNA相关的miRNA为啥你辛辛苦苦做的lncRNA会被reviewer毙掉如何绘制高大上的RNA二级结构图？（工具篇）：神器之——lncRNA编码能力预测如何查询分子的物种保守性？如何预测lncRNA的靶基因？ 环状RNA相关： 对于环状ＲＮＡ，我有个奇怪的想法，临床医生做到这一块的内容，实际上自己能做的少之又少，如何筛选环状ＲＮＡ，请公司做测序如何分析环状ＲＮＡ，生信公司给你作图如何设计引物验证，实际上你不会如何让ＲＮＡ成环，你也不会，请公司做如何敲减，还是不会，实际上很困难所以，一般的团队跟我讲，实际上是同学自豪地跟我说，他研究的方向是环状ＲＮＡ，实际上我的心内五味杂陈，最后汇成一句“你们团队好牛逼”circRNA 引物设计环状RNA定量PCR技术详解circRNA研究必备神器之傻瓜攻略大全你不能不知道的2个CircRNA研究在线工具！circRNA研究必备工具：circRNA翻译潜能预测非编码RNA真的不编码吗？9张图告诉你答案环状RNA翻译蛋白研究技术思路剖析Cell子刊连续两篇环状RNA翻译蛋白文章发表！circRNADb：首个汇总编码蛋白环状RNA的数据库Nature Reviews Genetics探讨环状RNA研究方法现状碎碎念：实际上看到这里的人不多，因为这样的帖子肯定是要收藏的，肯定是要跟自己说，以后会好好看的，可是多半不会看。大部分朋友蠢蠢欲动心急火燎地要学习生信，往往无疾而终，心灰意冷的时候，看看这篇帖子，你会重新打量人生，重振雄风的，因为你会发现，想要解决的问题，都有人给你提供方案了。]]></content>
      <categories>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习资源汇总]]></title>
    <url>%2F2017%2F10%2F17%2F02-machine-learning%2F</url>
    <content type="text"><![CDATA[我想到了一个课题，想要用机器学习来实现，实际上我现在还分不清，什么叫人工智能，机器学习，自然语义进程（Natural Language Processing，NLP），神经网络。我想要借助这个课题，完整地学习人工智能这个领域，最终我还要为自己写一份教程，教10个星期之前的自己如何轻松入门机器学习。计划采用的课程是Coursera上吴恩达老师的9周课程这是网上推荐的非官方笔记同时台湾大学李宏毅教授的课程也有人推荐在课程列表中还有一次线性代数的课程，可以帮助理解机器学习。我还让健明帮我在udemy上购买了Kirill Eremenko老师的机器学习课程Machine Learning A-Z™: Hands-On Python &amp; R In Data Science课程中用到的数据可以在这里下载因为Ｒ语言和Python在机器学习中十分重要，我报名参加了开智学堂的编程思维 Python 基础班四期如果完成Python课程后，我将继续参加他们的深度学习基础班这是他们老师写的入门导读一位工业界机器学习从业者的自我修炼在Udemy上我也购买了R和Python相关的课程。学习Python推荐的自学课程是：笨方法学Python同时选用搭配Automate the Boring Stuff with Python推荐的阅读是的文章是这几篇：深度学习如何入门？从零开始掌握Python机器学习：十四步教程英文版的在这：7 Steps to Mastering Machine Learning With Python7 More Steps to Mastering Machine Learning With Python下面这个课程也有人推荐，我先放在这里作者的书比较有名气，同时他也有网上免费的课程Carnegie Mellon University大学Tom Mitchell and Maria-Florina Balcan的Machine Learning重要的书籍吴军 数学之美南大周志华 机器学习]]></content>
      <categories>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R语言资源汇总]]></title>
    <url>%2F2017%2F10%2F17%2F01_R_resource%2F</url>
    <content type="text"><![CDATA[强烈推荐：这是DataCamp 的联合创始人 Martijn Theuwissen写的7步从零开始学习R，里面汇集了从0到高手需要的大部分资料，全部都是英文，并且给出了每个资源的链接。假如你的时间有限，这一篇一定要看。R Learning Path: From beginner to expert in R in 7 steps英文读不下去，可以先看一下这一篇中文介绍七步即可学会R语言，从此数据分析不再怕！当你入门了R语言后，看看这篇文章，里面总结了大部分数据处理时会用到的Ｒ包：RStartHere不想看英文，这是中文版本：学习R语言，一篇文章让你从懵圈到入门下面这个R语言进阶路径是R-bloggers网站和DataCamp合作推出的，里面涵盖了从入门到进阶的各种在线资源Tutorials for learning R而R-bloggers本身就是学习R语言特别好的网站。R for Data Science Hadley Wickham重新规范了数据处理的流程这本书相当于是给神包tidyverse的实战版，有书籍，也有网络免费版本，写得很好，强烈推荐。当你掌握了R的基本操作，能独立做分析，想提高可以看一下Hadley Wickham的这本书，我看到很多高手推荐：Advanced R第二版 以下的资源中除了中文资料，大部分内容都已经在第一个链接中推荐过 交互教程（适合入门）下面的课程我自己用过，这种循序渐进，一路保护的感觉，可以让你迅速入门你不需要下载R，安装包，就跟着他们走，就OK了。极其友好的的入门教程，全程走下来大概两个多小时，配合中文教程，急速入门Try R，注意要一口气学完，因为他没办法记录进度。 我更推荐的是这个来自Datacamp的入门教程，专业的入门教程，不需要任何背景，跟着教程走即可：Introduction to RDatacamp有完整的R语言英文教程，都能听得懂，名字叫Data Scientist with R，需要花费95小时。课程设置很有技巧，循序渐进。 网页：中文R语言网页教程，作为储备，防止看不懂英文：https://www.w3cschool.cn/r/r_overview.html英文R语言极简教程：http://www.r-tutor.com/r-introduction生信技能树骨干赵飞同学写的R必备基础知识R语言各个包里面的数据集在R语言里除了使用help还可以查阅rdocumentation 书籍：《R in Action》中文名称R语言实战，目前已经到了第二版《The Art of_R Programming》帮助Y叔入门R的电子书 http://www.burns-stat.com/documents/books/the-r-inferno/http://www.cookbook-r.com/这本小书是介绍R语言在生物信息学里面应用的a Little Book of R for Bioinformatics!JIMMY推荐的R语言大神回顾踩过的坑R语言忍者秘笈CRAN总结的很多电子书 R语言绘图：《ggplot2：数据分析与图形艺术》生物学家应该这样学R绘图-视频，数据，代码全公开Be Awesome in ggplot2: A Practical Guide to be Highly Effective - R software and data visualization严涛的翻译版本如下：ggplot2高效实用指南ggplot2高效实用指南（续） Bioconductor对于生信工作者bioconductor十分重要比如在网页的search部分输入TCGA，就会得到https://www.bioconductor.org/help/search/index.html?q=TCGA/立马感觉学习有了方向。此外要尝试参加一些线下的培训，比如生信技能树的培训，你去参加这样的互动，就是去开天眼的，学习是自己的事情，但是知道自己不知道才是智慧的开端。好吧，这些是外国的课程，说实话，我之前不知道R语言可以干这些事情。约翰•霍普金斯大学的Bioconductor学习课程斯坦福大学的暑期小课程-用bioconductor做统计分析如果觉得练的差不多了，来试试这些题目吧生信编程实战5个月传送门 高人指点：苦口婆心无比真诚的大神Jimmy–【生信菜鸟经】如何系统入门R语言独树一帜的大神Y叔–听说你想学R？银河统计：http://www.cnblogs.com/cloudtj/articles/5148848.html可爱的jimmy借鉴了这篇文章的第一段话解构R语言中的“黑魔法” 博客：Y叔的博客（博客排版有待提高）http://guangchuangyu.github.io/粉丝日志(强烈推荐)博主是张丹 http://blog.fens.me/他写了一系列关于R的文章 http://blog.fens.me/series-r/目前他主要从事量化交易软件的开发银河统计：这里汇总了关于R的56篇文章 http://www.cnblogs.com/cloudtj/category/780800.html任坤的博客，他是rlsit,pipeR的作者，他还写了一本书Learning R Programminghttp://renkun.me/生物日志-鸣一道糗世界Rmarkdown的作者，现在为Rstudio工作，我看过他的采访，说自己写作业排版太麻烦，特别愤怒的开发了Rmarkdown。严涛 浙江大学作物遗传育种在读研究生可视化做得非常好！！ 微信公众号： Ｒ语言中文社区 每天进步一点点2015，主要集中在R语言和Python的学习上，从数据分析到机器学习 R语言 生信者言]]></content>
      <categories>
        <category>生物信息</category>
      </categories>
      <tags>
        <tag>资源</tag>
        <tag>R</tag>
      </tags>
  </entry>
</search>
